name: Weekly Digest
'on':
  workflow_call:
    inputs:
      context-run-id:
        description: Run ID of the dispatcher workflow (for artifact download)
        required: true
        type: string
jobs:
  pre-flight:
    runs-on: ubuntu-latest
    outputs:
      should-run: ${{ steps.set-output.outputs.should-run || steps.check-rate-limit.outputs.should-run }}
      rate-limited: ${{ steps.check-rate-limit.outputs.rate-limited }}
      app-token: ${{ steps.app-token.outputs.token }}
      git-user: ${{ steps.app-token.outputs.git-user }}
      git-email: ${{ steps.app-token.outputs.git-email }}
    steps:
      - name: Download dispatch context
        uses: actions/download-artifact@v4
        with:
          name: dispatch-context-${{ inputs.context-run-id }}
          path: /tmp/dispatch-context/
          run-id: ${{ inputs.context-run-id }}
          github-token: ${{ secrets.GITHUB_TOKEN }}
      - name: Load dispatch context
        id: load-context
        run: |-
          if [ -f /tmp/dispatch-context/context.json ]; then
            echo "Dispatch context loaded:"
            cat /tmp/dispatch-context/context.json
            # Export context values as outputs
            echo "event-name=$(jq -r '.eventName' /tmp/dispatch-context/context.json)" >> $GITHUB_OUTPUT
            echo "event-action=$(jq -r '.eventAction' /tmp/dispatch-context/context.json)" >> $GITHUB_OUTPUT
          else
            echo "::error::Dispatch context not found"
            exit 1
          fi
      - name: Initialize audit tracking
        id: init-audit
        run: |-
          mkdir -p /tmp/audit
          echo '{
            "secrets_check": true,
            "user_authorization": false,
            "labels_check": false,
            "rate_limit_check": false
          }' > /tmp/audit/validation-status.json
          echo '[]' > /tmp/audit/permission-issues.json
      - name: Generate GitHub token
        id: app-token
        env:
          GH_APP_ID: ${{ secrets.GH_APP_ID }}
          GH_APP_PRIVATE_KEY: ${{ secrets.GH_APP_PRIVATE_KEY }}
          FALLBACK_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |-
          # Check if GitHub App is configured
          if [ -z "$GH_APP_ID" ] || [ -z "$GH_APP_PRIVATE_KEY" ]; then
            echo "No GitHub App configured, using default GITHUB_TOKEN"
            echo "token=$FALLBACK_TOKEN" >> $GITHUB_OUTPUT
            echo "git-user=github-actions[bot]" >> $GITHUB_OUTPUT
            echo "git-email=github-actions[bot]@users.noreply.github.com" >> $GITHUB_OUTPUT
            exit 0
          fi

          echo "GitHub App configured, generating installation token..."

          # Base64 URL-safe encoding function
          base64url() {
            openssl base64 -A | tr '+/' '-_' | tr -d '='
          }

          # Generate JWT header
          HEADER=$(echo -n '{"alg":"RS256","typ":"JWT"}' | base64url)

          # Generate JWT payload (iat = now - 60s to account for clock drift, exp = now + 10 min)
          NOW=$(date +%s)
          IAT=$((NOW - 60))
          EXP=$((NOW + 600))
          PAYLOAD=$(echo -n "{\"iat\":$IAT,\"exp\":$EXP,\"iss\":\"$GH_APP_ID\"}" | base64url)

          # Sign the JWT with the private key
          UNSIGNED="$HEADER.$PAYLOAD"
          SIGNATURE=$(echo -n "$UNSIGNED" | openssl dgst -sha256 -sign <(echo "$GH_APP_PRIVATE_KEY") | base64url)
          JWT="$HEADER.$PAYLOAD.$SIGNATURE"

          # Get installation ID for this repository
          OWNER="${{ github.repository_owner }}"
          REPO_NAME="${{ github.event.repository.name }}"
          INSTALLATION_RESPONSE=$(curl -s -H "Authorization: Bearer $JWT" \
            -H "Accept: application/vnd.github+json" \
            -H "X-GitHub-Api-Version: 2022-11-28" \
            "https://api.github.com/repos/$OWNER/$REPO_NAME/installation")

          INSTALLATION_ID=$(echo "$INSTALLATION_RESPONSE" | jq -r '.id // empty')

          if [ -z "$INSTALLATION_ID" ]; then
            echo "::warning::Failed to get installation ID. Is the GitHub App installed on this repository?"
            echo "::warning::Response: $INSTALLATION_RESPONSE"
            echo "Falling back to GITHUB_TOKEN"
            echo "token=$FALLBACK_TOKEN" >> $GITHUB_OUTPUT
            echo "git-user=github-actions[bot]" >> $GITHUB_OUTPUT
            echo "git-email=github-actions[bot]@users.noreply.github.com" >> $GITHUB_OUTPUT
            exit 0
          fi

          # Generate installation access token
          TOKEN_RESPONSE=$(curl -s -X POST \
            -H "Authorization: Bearer $JWT" \
            -H "Accept: application/vnd.github+json" \
            -H "X-GitHub-Api-Version: 2022-11-28" \
            "https://api.github.com/app/installations/$INSTALLATION_ID/access_tokens")

          TOKEN=$(echo "$TOKEN_RESPONSE" | jq -r '.token // empty')

          if [ -z "$TOKEN" ]; then
            echo "::warning::Failed to generate installation token"
            echo "::warning::Response: $TOKEN_RESPONSE"
            echo "Falling back to GITHUB_TOKEN"
            echo "token=$FALLBACK_TOKEN" >> $GITHUB_OUTPUT
            echo "git-user=github-actions[bot]" >> $GITHUB_OUTPUT
            echo "git-email=github-actions[bot]@users.noreply.github.com" >> $GITHUB_OUTPUT
            exit 0
          fi

          # Mask the token in logs
          echo "::add-mask::$TOKEN"

          # Get app info for git identity
          APP_RESPONSE=$(curl -s -H "Authorization: Bearer $JWT" \
            -H "Accept: application/vnd.github+json" \
            -H "X-GitHub-Api-Version: 2022-11-28" \
            "https://api.github.com/app")

          APP_SLUG=$(echo "$APP_RESPONSE" | jq -r '.slug // "github-app"')
          APP_ID_NUM=$(echo "$APP_RESPONSE" | jq -r '.id // "0"')

          echo "âœ“ Generated GitHub App token for $APP_SLUG"
          echo "token=$TOKEN" >> $GITHUB_OUTPUT
          echo "git-user=$APP_SLUG[bot]" >> $GITHUB_OUTPUT
          echo "git-email=$APP_ID_NUM+$APP_SLUG[bot]@users.noreply.github.com" >> $GITHUB_OUTPUT
      - name: Check user authorization
        id: check-user
        env:
          GITHUB_TOKEN: ${{ steps.app-token.outputs.token }}
        run: |-
          ACTOR="${{ github.actor }}"
          USER_ASSOCIATION=$(gh api "repos/${{ github.repository }}/collaborators/${ACTOR}/permission" --jq '.permission' 2>/dev/null || echo "")

          if [ "${USER_ASSOCIATION}" = "admin" ] || [ "${USER_ASSOCIATION}" = "write" ]; then
            echo "âœ“ User ${ACTOR} has ${USER_ASSOCIATION} permission"
          else
            # Check if user is an org member
            ORG_MEMBER=$(gh api "orgs/${{ github.repository_owner }}/members/${ACTOR}" 2>/dev/null && echo "true" || echo "false")
            if [ "${ORG_MEMBER}" = "true" ]; then
              echo "âœ“ User ${ACTOR} is an organization member"
            else
              echo "::error::User ${ACTOR} does not have sufficient permissions"
              jq '. += [{
                "timestamp": "'$(date -u +%Y-%m-%dT%H:%M:%SZ)'",
                "issue_type": "missing_permission",
                "severity": "error",
                "message": "User not authorized",
                "context": {"user": "'${ACTOR}'", "permission": "'${USER_ASSOCIATION}'"}
              }]' /tmp/audit/permission-issues.json > /tmp/audit/permission-issues.tmp
              mv /tmp/audit/permission-issues.tmp /tmp/audit/permission-issues.json
              echo "validation-failed=true" >> $GITHUB_OUTPUT
              exit 1
            fi
          fi

          jq '.user_authorization = true' /tmp/audit/validation-status.json > /tmp/audit/validation-status.tmp
          mv /tmp/audit/validation-status.tmp /tmp/audit/validation-status.json
      - name: Check rate limit
        id: check-rate-limit
        env:
          GITHUB_TOKEN: ${{ steps.app-token.outputs.token }}
        run: |-
          RATE_LIMIT_MINUTES=10080

          # Get recent workflow runs for this workflow
          RECENT_RUNS=$(gh api "repos/${{ github.repository }}/actions/runs" \
            --jq "[.workflow_runs[] | select(.name == \"${{ github.workflow }}\" and .status == \"completed\" and .conclusion == \"success\")] | .[0:5] | .[].created_at" 2>/dev/null || echo "")

          if [ -n "${RECENT_RUNS}" ]; then
            CURRENT_TIME=$(date +%s)

            for run_time in ${RECENT_RUNS}; do
              RUN_TIMESTAMP=$(date -d "${run_time}" +%s 2>/dev/null || date -j -f "%Y-%m-%dT%H:%M:%SZ" "${run_time}" +%s 2>/dev/null || echo "0")
              TIME_DIFF=$(( (CURRENT_TIME - RUN_TIMESTAMP) / 60 ))

              if [ "${TIME_DIFF}" -lt "${RATE_LIMIT_MINUTES}" ]; then
                echo "::notice::Rate limit: Agent ran ${TIME_DIFF} minutes ago. Minimum interval is ${RATE_LIMIT_MINUTES} minutes."
                echo "should-run=false" >> $GITHUB_OUTPUT
                echo "rate-limited=true" >> $GITHUB_OUTPUT
                exit 0
              fi
            done
          fi
          echo "âœ“ Rate limit check passed"

          jq '.rate_limit_check = true' /tmp/audit/validation-status.json > /tmp/audit/validation-status.tmp
          mv /tmp/audit/validation-status.tmp /tmp/audit/validation-status.json
      - name: Set output
        id: set-output
        run: |-
          echo "should-run=true" >> $GITHUB_OUTPUT
          echo "âœ“ All validation checks passed"
      - name: Upload validation audit data
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: validation-audit
          path: /tmp/audit/
          if-no-files-found: ignore

  collect-inputs:
    runs-on: ubuntu-latest
    needs: pre-flight
    if: needs.pre-flight.outputs.should-run == 'true'
    outputs:
      has-inputs: ${{ steps.collect.outputs.has-inputs }}
      inputs-data: ${{ steps.collect.outputs.inputs-data }}
    steps:
      - name: Generate GitHub token
        id: app-token
        env:
          GH_APP_ID: ${{ secrets.GH_APP_ID }}
          GH_APP_PRIVATE_KEY: ${{ secrets.GH_APP_PRIVATE_KEY }}
          FALLBACK_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |-
          # Check if GitHub App is configured
          if [ -z "$GH_APP_ID" ] || [ -z "$GH_APP_PRIVATE_KEY" ]; then
            echo "No GitHub App configured, using default GITHUB_TOKEN"
            echo "token=$FALLBACK_TOKEN" >> $GITHUB_OUTPUT
            echo "git-user=github-actions[bot]" >> $GITHUB_OUTPUT
            echo "git-email=github-actions[bot]@users.noreply.github.com" >> $GITHUB_OUTPUT
            exit 0
          fi

          echo "GitHub App configured, generating installation token..."

          # Base64 URL-safe encoding function
          base64url() {
            openssl base64 -A | tr '+/' '-_' | tr -d '='
          }

          # Generate JWT header
          HEADER=$(echo -n '{"alg":"RS256","typ":"JWT"}' | base64url)

          # Generate JWT payload (iat = now - 60s to account for clock drift, exp = now + 10 min)
          NOW=$(date +%s)
          IAT=$((NOW - 60))
          EXP=$((NOW + 600))
          PAYLOAD=$(echo -n "{\"iat\":$IAT,\"exp\":$EXP,\"iss\":\"$GH_APP_ID\"}" | base64url)

          # Sign the JWT with the private key
          UNSIGNED="$HEADER.$PAYLOAD"
          SIGNATURE=$(echo -n "$UNSIGNED" | openssl dgst -sha256 -sign <(echo "$GH_APP_PRIVATE_KEY") | base64url)
          JWT="$HEADER.$PAYLOAD.$SIGNATURE"

          # Get installation ID for this repository
          OWNER="${{ github.repository_owner }}"
          REPO_NAME="${{ github.event.repository.name }}"
          INSTALLATION_RESPONSE=$(curl -s -H "Authorization: Bearer $JWT" \
            -H "Accept: application/vnd.github+json" \
            -H "X-GitHub-Api-Version: 2022-11-28" \
            "https://api.github.com/repos/$OWNER/$REPO_NAME/installation")

          INSTALLATION_ID=$(echo "$INSTALLATION_RESPONSE" | jq -r '.id // empty')

          if [ -z "$INSTALLATION_ID" ]; then
            echo "::warning::Failed to get installation ID. Is the GitHub App installed on this repository?"
            echo "::warning::Response: $INSTALLATION_RESPONSE"
            echo "Falling back to GITHUB_TOKEN"
            echo "token=$FALLBACK_TOKEN" >> $GITHUB_OUTPUT
            echo "git-user=github-actions[bot]" >> $GITHUB_OUTPUT
            echo "git-email=github-actions[bot]@users.noreply.github.com" >> $GITHUB_OUTPUT
            exit 0
          fi

          # Generate installation access token
          TOKEN_RESPONSE=$(curl -s -X POST \
            -H "Authorization: Bearer $JWT" \
            -H "Accept: application/vnd.github+json" \
            -H "X-GitHub-Api-Version: 2022-11-28" \
            "https://api.github.com/app/installations/$INSTALLATION_ID/access_tokens")

          TOKEN=$(echo "$TOKEN_RESPONSE" | jq -r '.token // empty')

          if [ -z "$TOKEN" ]; then
            echo "::warning::Failed to generate installation token"
            echo "::warning::Response: $TOKEN_RESPONSE"
            echo "Falling back to GITHUB_TOKEN"
            echo "token=$FALLBACK_TOKEN" >> $GITHUB_OUTPUT
            echo "git-user=github-actions[bot]" >> $GITHUB_OUTPUT
            echo "git-email=github-actions[bot]@users.noreply.github.com" >> $GITHUB_OUTPUT
            exit 0
          fi

          # Mask the token in logs
          echo "::add-mask::$TOKEN"

          # Get app info for git identity
          APP_RESPONSE=$(curl -s -H "Authorization: Bearer $JWT" \
            -H "Accept: application/vnd.github+json" \
            -H "X-GitHub-Api-Version: 2022-11-28" \
            "https://api.github.com/app")

          APP_SLUG=$(echo "$APP_RESPONSE" | jq -r '.slug // "github-app"')
          APP_ID_NUM=$(echo "$APP_RESPONSE" | jq -r '.id // "0"')

          echo "âœ“ Generated GitHub App token for $APP_SLUG"
          echo "token=$TOKEN" >> $GITHUB_OUTPUT
          echo "git-user=$APP_SLUG[bot]" >> $GITHUB_OUTPUT
          echo "git-email=$APP_ID_NUM+$APP_SLUG[bot]@users.noreply.github.com" >> $GITHUB_OUTPUT
      - name: Collect repository data
        id: collect
        env:
          GITHUB_TOKEN: ${{ steps.app-token.outputs.token }}
        run: |-
          #!/bin/bash
          set -e

          # Input Collection Script
          # Collects configured inputs from GitHub and formats them for Claude

          COLLECTED_DATA=""
          TOTAL_ITEMS=0

          # Determine time filter
          # Calculate time filter based on 'since' configuration
          if [ "7d" = "last-run" ]; then
            # Get timestamp of last successful run
            # Note: Using repo-level runs endpoint and filtering by workflow name to avoid URL encoding issues
            LAST_RUN=$(gh api "repos/${{ github.repository }}/actions/runs" \
              --jq '[.workflow_runs[] | select(.name == "${{ github.workflow }}" and .status == "completed" and .conclusion == "success")] | .[0].created_at' 2>/dev/null || echo "")

            if [ -n "$LAST_RUN" ]; then
              SINCE_DATE="$LAST_RUN"
              echo "â„¹ï¸  Collecting data since last run: $SINCE_DATE"
            else
              # No previous run, default to 24 hours
              SINCE_DATE=$(date -u -d '24 hours ago' +%Y-%m-%dT%H:%M:%SZ 2>/dev/null || date -u -v-24H +%Y-%m-%dT%H:%M:%SZ 2>/dev/null)
              echo "â„¹ï¸  No previous run found, collecting data from last 24 hours"
            fi
          else
            # Parse time duration (e.g., "1h", "24h", "7d")
            DURATION="7d"
            if [[ "$DURATION" =~ ^([0-9]+)h$ ]]; then
              HOURS="${BASH_REMATCH[1]}"
              SINCE_DATE=$(date -u -d "$HOURS hours ago" +%Y-%m-%dT%H:%M:%SZ 2>/dev/null || date -u -v-${HOURS}H +%Y-%m-%dT%H:%M:%SZ 2>/dev/null)
            elif [[ "$DURATION" =~ ^([0-9]+)d$ ]]; then
              DAYS="${BASH_REMATCH[1]}"
              SINCE_DATE=$(date -u -d "$DAYS days ago" +%Y-%m-%dT%H:%M:%SZ 2>/dev/null || date -u -v-${DAYS}d +%Y-%m-%dT%H:%M:%SZ 2>/dev/null)
            else
              # Default to 24 hours if invalid format
              SINCE_DATE=$(date -u -d '24 hours ago' +%Y-%m-%dT%H:%M:%SZ 2>/dev/null || date -u -v-24H +%Y-%m-%dT%H:%M:%SZ 2>/dev/null)
            fi
            echo "â„¹ï¸  Collecting data since: $SINCE_DATE (duration: $DURATION)"
          fi

          # Collect Issues
          echo "## ðŸ“‹ Issues" >> /tmp/issues_section.md
          echo "" >> /tmp/issues_section.md

          ISSUES_COUNT=0
          ISSUES_JSON=$(gh api "repos/${{ github.repository }}/issues?state=all&per_page=200" \
            --paginate \
            --jq '[.[] | select(.pull_request == null and (.updated_at >= "'$SINCE_DATE'"))]' 2>/dev/null || echo "[]")

          # Filter by labels if specified



          ISSUES_COUNT=$(echo "$ISSUES_JSON" | jq 'length')
          TOTAL_ITEMS=$((TOTAL_ITEMS + ISSUES_COUNT))

          if [ "$ISSUES_COUNT" -gt 0 ]; then
            echo "Found $ISSUES_COUNT issue(s)"

            echo "$ISSUES_JSON" | jq -r '.[] |
              "### [#" + (.number|tostring) + "] " + .title + "\n" +
              "**State:** " + .state + " | **Author:** @" + .user.login + " | **Updated:** " + .updated_at + "\n" +
              "**Labels:** " + ([.labels[].name] | join(", ")) + "\n" +
              "**URL:** " + .html_url + "\n" +
              (if .body then "\n" + .body + "\n" else "" end) +
              "---\n"
            ' >> /tmp/issues_section.md

            COLLECTED_DATA="$COLLECTED_DATA$(cat /tmp/issues_section.md)"
          else
            echo "No issues found"
          fi

          # Collect Pull Requests
          echo "## ðŸ”€ Pull Requests" >> /tmp/prs_section.md
          echo "" >> /tmp/prs_section.md

          PRS_COUNT=0
          PRS_JSON=$(gh api "repos/${{ github.repository }}/pulls?state=all&per_page=200" \
            --paginate \
            --jq '[.[] | select(.updated_at >= "'$SINCE_DATE'")]' 2>/dev/null || echo "[]")

          # Filter by labels if specified



          # Filter merged PRs if only merged is requested


          PRS_COUNT=$(echo "$PRS_JSON" | jq 'length')
          TOTAL_ITEMS=$((TOTAL_ITEMS + PRS_COUNT))

          if [ "$PRS_COUNT" -gt 0 ]; then
            echo "Found $PRS_COUNT pull request(s)"

            echo "$PRS_JSON" | jq -r '.[] |
              "### [#" + (.number|tostring) + "] " + .title + "\n" +
              "**State:** " + .state + (if .merged_at then " (merged)" else "" end) + " | **Author:** @" + .user.login + " | **Updated:** " + .updated_at + "\n" +
              "**Branch:** " + .head.ref + " â†’ " + .base.ref + "\n" +
              "**Labels:** " + ([.labels[].name] | join(", ")) + "\n" +
              "**URL:** " + .html_url + "\n" +
              (if .body then "\n" + .body + "\n" else "" end) +
              "---\n"
            ' >> /tmp/prs_section.md

            COLLECTED_DATA="$COLLECTED_DATA$(cat /tmp/prs_section.md)"
          else
            echo "No pull requests found"
          fi

          # Collect Commits
          echo "## ðŸ“ Commits" >> /tmp/commits_section.md
          echo "" >> /tmp/commits_section.md

          COMMITS_COUNT=0
          BRANCHES=("main")

          for BRANCH in "${BRANCHES[@]}"; do
            # Check if branch exists
            if ! gh api "repos/${{ github.repository }}/branches/$BRANCH" >/dev/null 2>&1; then
              continue
            fi

            BRANCH_COMMITS=$(gh api "repos/${{ github.repository }}/commits" \
              -f sha="$BRANCH" \
              -f since="$SINCE_DATE" \
              -f per_page="500" \
              --jq '.[] | {
                sha: .sha[0:7],
                message: .commit.message | split("\n")[0],
                author: .commit.author.name,
                date: .commit.author.date,
                url: .html_url
              }' 2>/dev/null || echo "")

            if [ -n "$BRANCH_COMMITS" ]; then
              echo "Found commits on branch: $BRANCH"
              echo "$BRANCH_COMMITS" | jq -r '
                "- [`" + .sha + "`](" + .url + ") " + .message + " - @" + .author + " (" + .date + ")\n"
              ' >> /tmp/commits_section.md

              BRANCH_COUNT=$(echo "$BRANCH_COMMITS" | jq -s 'length')
              COMMITS_COUNT=$((COMMITS_COUNT + BRANCH_COUNT))
            fi
          done

          TOTAL_ITEMS=$((TOTAL_ITEMS + COMMITS_COUNT))

          if [ "$COMMITS_COUNT" -gt 0 ]; then
            echo "Found $COMMITS_COUNT commit(s)"
            COLLECTED_DATA="$COLLECTED_DATA$(cat /tmp/commits_section.md)"
          else
            echo "No commits found"
          fi

          # Collect Releases
          echo "## ðŸš€ Releases" >> /tmp/releases_section.md
          echo "" >> /tmp/releases_section.md

          RELEASES_COUNT=0
          RELEASES_JSON=$(gh api "repos/${{ github.repository }}/releases?per_page=20" \
            --jq '[.[] | select(.created_at >= "'$SINCE_DATE'")]' 2>/dev/null || echo "[]")


          # Exclude drafts
          RELEASES_JSON=$(echo "$RELEASES_JSON" | jq '[.[] | select(.draft == false)]')

          RELEASES_COUNT=$(echo "$RELEASES_JSON" | jq 'length')
          TOTAL_ITEMS=$((TOTAL_ITEMS + RELEASES_COUNT))

          if [ "$RELEASES_COUNT" -gt 0 ]; then
            echo "Found $RELEASES_COUNT release(s)"

            echo "$RELEASES_JSON" | jq -r '.[] |
              "### " + .tag_name + " - " + .name + "\n" +
              "**Author:** @" + .author.login + " | **Published:** " + .published_at + "\n" +
              (if .prerelease then "**Type:** Pre-release\n" else "**Type:** Release\n" end) +
              "**URL:** " + .html_url + "\n" +
              (if .body then "\n" + .body + "\n" else "" end) +
              "---\n"
            ' >> /tmp/releases_section.md

            COLLECTED_DATA="$COLLECTED_DATA$(cat /tmp/releases_section.md)"
          else
            echo "No releases found"
          fi

          # Check if we have minimum items
          if [ "$TOTAL_ITEMS" -lt "5" ]; then
            echo "âš ï¸  Only found $TOTAL_ITEMS items (minimum: 5). Skipping agent execution."
            echo "has-inputs=false" >> $GITHUB_OUTPUT
            exit 0
          fi

          echo "âœ“ Collected $TOTAL_ITEMS items"
          echo "has-inputs=true" >> $GITHUB_OUTPUT

          # Save collected data to file for next job
          echo "$COLLECTED_DATA" > /tmp/inputs.md

          # Output as GitHub output (truncated if too long)
          TRUNCATED_DATA=$(echo "$COLLECTED_DATA" | head -c 100000)
          echo "inputs-data<<EOF" >> $GITHUB_OUTPUT
          echo "$TRUNCATED_DATA" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

  claude-agent:
    runs-on: ubuntu-latest
    needs:
      - pre-flight
      - collect-inputs
    if: needs.pre-flight.outputs.should-run == 'true' && needs.collect-inputs.outputs.has-inputs == 'true'
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
      - name: Download dispatch context
        uses: actions/download-artifact@v4
        with:
          name: dispatch-context-${{ inputs.context-run-id }}
          path: /tmp/dispatch-context/
          run-id: ${{ inputs.context-run-id }}
          github-token: ${{ secrets.GITHUB_TOKEN }}
      - name: Setup Bun
        uses: oven-sh/setup-bun@v2
        with:
          bun-version: latest
      - name: Create outputs directory
        run: mkdir -p /tmp/outputs /tmp/validation-errors
      - name: Prepare context file
        id: prepare
        run: |-
          # Build context from dispatch context artifact
          EVENT_NAME=$(jq -r '.eventName' /tmp/dispatch-context/context.json)
          REPOSITORY=$(jq -r '.repository' /tmp/dispatch-context/context.json)

          cat > /tmp/context.txt << CONTEXT_EOF
          GitHub Event: ${EVENT_NAME}
          Repository: ${REPOSITORY}
          CONTEXT_EOF

          # Add issue context if present
          if jq -e '.issue' /tmp/dispatch-context/context.json > /dev/null 2>&1; then
            ISSUE_NUMBER=$(jq -r '.issue.number' /tmp/dispatch-context/context.json)
            ISSUE_TITLE=$(jq -r '.issue.title' /tmp/dispatch-context/context.json)
            ISSUE_AUTHOR=$(jq -r '.issue.author' /tmp/dispatch-context/context.json)
            ISSUE_BODY=$(jq -r '.issue.body' /tmp/dispatch-context/context.json)

            cat >> /tmp/context.txt << ISSUE_EOF
          Issue #${ISSUE_NUMBER}: ${ISSUE_TITLE}
          Author: @${ISSUE_AUTHOR}
          Body:
          ${ISSUE_BODY}
          ISSUE_EOF
          fi

          # Add PR context if present
          if jq -e '.pullRequest' /tmp/dispatch-context/context.json > /dev/null 2>&1; then
            PR_NUMBER=$(jq -r '.pullRequest.number' /tmp/dispatch-context/context.json)
            PR_TITLE=$(jq -r '.pullRequest.title' /tmp/dispatch-context/context.json)
            PR_AUTHOR=$(jq -r '.pullRequest.author' /tmp/dispatch-context/context.json)
            PR_BODY=$(jq -r '.pullRequest.body' /tmp/dispatch-context/context.json)

            cat >> /tmp/context.txt << PR_EOF
          PR #${PR_NUMBER}: ${PR_TITLE}
          Author: @${PR_AUTHOR}
          Body:
          ${PR_BODY}
          PR_EOF
          fi

          # Add discussion context if present
          if jq -e '.discussion' /tmp/dispatch-context/context.json > /dev/null 2>&1; then
            DISC_NUMBER=$(jq -r '.discussion.number' /tmp/dispatch-context/context.json)
            DISC_TITLE=$(jq -r '.discussion.title' /tmp/dispatch-context/context.json)
            DISC_AUTHOR=$(jq -r '.discussion.author' /tmp/dispatch-context/context.json)
            DISC_BODY=$(jq -r '.discussion.body' /tmp/dispatch-context/context.json)
            DISC_CATEGORY=$(jq -r '.discussion.category' /tmp/dispatch-context/context.json)

            cat >> /tmp/context.txt << DISC_EOF
          Discussion #${DISC_NUMBER}: ${DISC_TITLE}
          Category: ${DISC_CATEGORY}
          Author: @${DISC_AUTHOR}
          Body:
          ${DISC_BODY}
          DISC_EOF
          fi
      - name: Add collected inputs to context
        if: needs.collect-inputs.outputs.has-inputs == 'true'
        run: |-
          cat >> /tmp/context.txt << 'INPUTS_EOF'

          ## Collected Inputs

          The following data has been collected from the repository:

          ${{ needs.collect-inputs.outputs.inputs-data }}
          INPUTS_EOF
      - name: Create Claude skills file
        run: |-
          mkdir -p .claude && cat > .claude/CLAUDE.md << 'SKILLS_EOF'
          # Agent Output Skills

          This file documents how to create outputs for this agent.

          ## Skill: Add Comment

          Add a comment to the current issue or pull request.

          **File to create**: \`/tmp/outputs/add-comment.json\`

          For multiple comments, use numbered suffixes: \`add-comment-1.json\`, \`add-comment-2.json\`, etc.

          **JSON Schema**:
          \`\`\`json
          {
            "body": "string"
          }
          \`\`\`

          **Fields**:
          - \`body\` (required): Markdown-formatted comment text

          **Constraints**:
          - Maximum comments: unlimited
          - Body must be non-empty

          **Example**:
          Create \`/tmp/outputs/add-comment.json\` with:
          \`\`\`json
          {
            "body": "Thank you for reporting this issue! I've analyzed it and added appropriate labels."
          }
          \`\`\`

          Or for multiple comments:
          - \`/tmp/outputs/add-comment-1.json\`
          - \`/tmp/outputs/add-comment-2.json\`

          **Important**: Use the Write tool to create this file. Only create the file when you're ready to post the comment.

          SKILLS_EOF
      - name: Add agent instructions
        run: |-
          cat >> /tmp/context.txt << 'INSTRUCTIONS_EOF'

          ---

          You are a weekly digest agent that summarizes repository activity over the past week.

          ## Your Task

          Create an engaging weekly digest that helps the team understand what happened in the repository over the past 7 days.

          ### Analysis Guidelines

          1. **Weekly Highlights** (top of digest)
             - Biggest achievements (merged PRs, shipped features)
             - Notable releases or milestones
             - Community contributions to celebrate

          2. **Development Activity**
             - How many commits were made?
             - Who were the top contributors?
             - What areas of the codebase saw the most changes?

          3. **Issue & PR Tracking**
             - Issues opened vs closed (net change)
             - PRs merged vs opened (velocity indicator)
             - Oldest open issues/PRs that need attention

          4. **Trends & Insights**
             - Is the issue backlog growing or shrinking?
             - What topics are people discussing most?
             - Any patterns in failures or bugs?

          5. **Looking Ahead**
             - What's in progress for next week?
             - Any blockers or concerns?

          ## Output Format

          Post a discussion in the "Announcements" category with:
          - Title: "Weekly Digest - Week of [Start Date]"
          - Engaging summary with emojis
          - Clear sections for each category
          - Data-driven insights
          - Links to relevant issues/PRs

          Keep it informative but concise - aim for a 2-3 minute read.
          INSTRUCTIONS_EOF
      - name: Install Claude Code CLI
        run: bunx --bun @anthropic-ai/claude-code --version
      - name: Run Claude Agent
        id: run-claude
        env:
          ANTHROPIC_API_KEY: ${{ secrets.ANTHROPIC_API_KEY }}
          CLAUDE_CODE_OAUTH_TOKEN: ${{ secrets.CLAUDE_CODE_OAUTH_TOKEN }}
          GITHUB_TOKEN: ${{ steps.app-token.outputs.token }}
          GH_TOKEN: ${{ steps.app-token.outputs.token }}
        run: bunx --bun @anthropic-ai/claude-code -p "$(cat /tmp/context.txt)" --allowedTools "Write(/tmp/outputs/*),Read,Glob,Grep" --permission-mode bypassPermissions --output-format json > /tmp/claude-output.json
      - name: Extract execution metrics
        id: extract-metrics
        if: always()
        run: |-
          if [ -f /tmp/claude-output.json ]; then
            echo "=== Claude Execution Summary ==="

            # Extract metrics using jq
            COST=$(jq -r '.total_cost_usd // "N/A"' /tmp/claude-output.json)
            TURNS=$(jq -r '.num_turns // "N/A"' /tmp/claude-output.json)
            DURATION=$(jq -r '.duration_ms // "N/A"' /tmp/claude-output.json)
            IS_ERROR=$(jq -r '.is_error // false' /tmp/claude-output.json)

            echo "Cost: \$${COST}"
            echo "Turns: ${TURNS}"
            echo "Duration: ${DURATION}ms"
            echo "Error: ${IS_ERROR}"

            # Set outputs for downstream jobs
            echo "cost=${COST}" >> $GITHUB_OUTPUT
            echo "turns=${TURNS}" >> $GITHUB_OUTPUT
            echo "duration=${DURATION}" >> $GITHUB_OUTPUT
            echo "is-error=${IS_ERROR}" >> $GITHUB_OUTPUT

            if [ "${IS_ERROR}" = "true" ]; then
              echo "claude-error=true" >> $GITHUB_OUTPUT
              echo "::warning::Claude execution completed with errors"
            fi
          else
            echo "::warning::Claude output file not found"
            echo "cost=N/A" >> $GITHUB_OUTPUT
            echo "turns=N/A" >> $GITHUB_OUTPUT
            echo "duration=N/A" >> $GITHUB_OUTPUT
            echo "is-error=true" >> $GITHUB_OUTPUT
            echo "claude-error=true" >> $GITHUB_OUTPUT
          fi
      - name: Upload outputs
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: claude-outputs
          path: /tmp/outputs/
          if-no-files-found: ignore
      - name: Upload Claude execution data
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: claude-execution
          path: /tmp/claude-output.json
          if-no-files-found: ignore

  execute-outputs:
    runs-on: ubuntu-latest
    needs: claude-agent
    if: success() && needs.claude-agent.result == 'success'
    strategy:
      matrix:
        output-type:
          - add-comment
      fail-fast: false
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
      - name: Generate GitHub token
        id: app-token
        env:
          GH_APP_ID: ${{ secrets.GH_APP_ID }}
          GH_APP_PRIVATE_KEY: ${{ secrets.GH_APP_PRIVATE_KEY }}
          FALLBACK_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |-
          # Check if GitHub App is configured
          if [ -z "$GH_APP_ID" ] || [ -z "$GH_APP_PRIVATE_KEY" ]; then
            echo "No GitHub App configured, using default GITHUB_TOKEN"
            echo "token=$FALLBACK_TOKEN" >> $GITHUB_OUTPUT
            echo "git-user=github-actions[bot]" >> $GITHUB_OUTPUT
            echo "git-email=github-actions[bot]@users.noreply.github.com" >> $GITHUB_OUTPUT
            exit 0
          fi

          echo "GitHub App configured, generating installation token..."

          # Base64 URL-safe encoding function
          base64url() {
            openssl base64 -A | tr '+/' '-_' | tr -d '='
          }

          # Generate JWT header
          HEADER=$(echo -n '{"alg":"RS256","typ":"JWT"}' | base64url)

          # Generate JWT payload (iat = now - 60s to account for clock drift, exp = now + 10 min)
          NOW=$(date +%s)
          IAT=$((NOW - 60))
          EXP=$((NOW + 600))
          PAYLOAD=$(echo -n "{\"iat\":$IAT,\"exp\":$EXP,\"iss\":\"$GH_APP_ID\"}" | base64url)

          # Sign the JWT with the private key
          UNSIGNED="$HEADER.$PAYLOAD"
          SIGNATURE=$(echo -n "$UNSIGNED" | openssl dgst -sha256 -sign <(echo "$GH_APP_PRIVATE_KEY") | base64url)
          JWT="$HEADER.$PAYLOAD.$SIGNATURE"

          # Get installation ID for this repository
          OWNER="${{ github.repository_owner }}"
          REPO_NAME="${{ github.event.repository.name }}"
          INSTALLATION_RESPONSE=$(curl -s -H "Authorization: Bearer $JWT" \
            -H "Accept: application/vnd.github+json" \
            -H "X-GitHub-Api-Version: 2022-11-28" \
            "https://api.github.com/repos/$OWNER/$REPO_NAME/installation")

          INSTALLATION_ID=$(echo "$INSTALLATION_RESPONSE" | jq -r '.id // empty')

          if [ -z "$INSTALLATION_ID" ]; then
            echo "::warning::Failed to get installation ID. Is the GitHub App installed on this repository?"
            echo "::warning::Response: $INSTALLATION_RESPONSE"
            echo "Falling back to GITHUB_TOKEN"
            echo "token=$FALLBACK_TOKEN" >> $GITHUB_OUTPUT
            echo "git-user=github-actions[bot]" >> $GITHUB_OUTPUT
            echo "git-email=github-actions[bot]@users.noreply.github.com" >> $GITHUB_OUTPUT
            exit 0
          fi

          # Generate installation access token
          TOKEN_RESPONSE=$(curl -s -X POST \
            -H "Authorization: Bearer $JWT" \
            -H "Accept: application/vnd.github+json" \
            -H "X-GitHub-Api-Version: 2022-11-28" \
            "https://api.github.com/app/installations/$INSTALLATION_ID/access_tokens")

          TOKEN=$(echo "$TOKEN_RESPONSE" | jq -r '.token // empty')

          if [ -z "$TOKEN" ]; then
            echo "::warning::Failed to generate installation token"
            echo "::warning::Response: $TOKEN_RESPONSE"
            echo "Falling back to GITHUB_TOKEN"
            echo "token=$FALLBACK_TOKEN" >> $GITHUB_OUTPUT
            echo "git-user=github-actions[bot]" >> $GITHUB_OUTPUT
            echo "git-email=github-actions[bot]@users.noreply.github.com" >> $GITHUB_OUTPUT
            exit 0
          fi

          # Mask the token in logs
          echo "::add-mask::$TOKEN"

          # Get app info for git identity
          APP_RESPONSE=$(curl -s -H "Authorization: Bearer $JWT" \
            -H "Accept: application/vnd.github+json" \
            -H "X-GitHub-Api-Version: 2022-11-28" \
            "https://api.github.com/app")

          APP_SLUG=$(echo "$APP_RESPONSE" | jq -r '.slug // "github-app"')
          APP_ID_NUM=$(echo "$APP_RESPONSE" | jq -r '.id // "0"')

          echo "âœ“ Generated GitHub App token for $APP_SLUG"
          echo "token=$TOKEN" >> $GITHUB_OUTPUT
          echo "git-user=$APP_SLUG[bot]" >> $GITHUB_OUTPUT
          echo "git-email=$APP_ID_NUM+$APP_SLUG[bot]@users.noreply.github.com" >> $GITHUB_OUTPUT
      - name: Download outputs artifact
        uses: actions/download-artifact@v4
        with:
          name: agent-outputs
          path: /tmp/outputs
        continue-on-error: true
      - name: Create validation errors directory
        run: mkdir -p /tmp/validation-errors
      - name: Validate and execute ${{ matrix.output-type }}
        env:
          GITHUB_TOKEN: ${{ steps.app-token.outputs.token }}
          GIT_USER: ${{ steps.app-token.outputs.git-user }}
          GIT_EMAIL: ${{ steps.app-token.outputs.git-email }}
        run: |

          if [ "${{ matrix.output-type }}" = "add-comment" ]; then

          # Validate and execute add-comment output(s)
          COMMENT_FILES=$(find /tmp/outputs -name "add-comment*.json" 2>/dev/null || true)

          if [ -n "$COMMENT_FILES" ]; then
            # Count files
            FILE_COUNT=$(echo "$COMMENT_FILES" | wc -l)
            echo "Found $FILE_COUNT add-comment output file(s)"

            # Check max constraint
            

            # Phase 1: Validate all files
            VALIDATION_FAILED=false
            for comment_file in $COMMENT_FILES; do
              echo "Validating $comment_file..."

              # Validate JSON structure
              if ! jq empty "$comment_file" 2>/dev/null; then
                echo "- **add-comment**: Invalid JSON format in $comment_file" >> /tmp/validation-errors/add-comment.txt
                VALIDATION_FAILED=true
                continue
              fi

              # Extract body
              COMMENT_BODY=$(jq -r '.body' "$comment_file")

              # Validate body is non-empty
              if [ -z "$COMMENT_BODY" ] || [ "$COMMENT_BODY" = "null" ]; then
                echo "- **add-comment**: Comment body is empty or missing in $comment_file" >> /tmp/validation-errors/add-comment.txt
                VALIDATION_FAILED=true
                continue
              elif [ ${#COMMENT_BODY} -gt 65536 ]; then
                echo "- **add-comment**: Comment body exceeds 65536 characters in $comment_file" >> /tmp/validation-errors/add-comment.txt
                VALIDATION_FAILED=true
                continue
              fi

              echo "âœ“ Validation passed for $comment_file"
            done

            # Check if we have an issue/PR number
            ISSUE_NUMBER="${{ github.event.issue.number }}${{ github.event.pull_request.number }}"
            if [ -z "$ISSUE_NUMBER" ]; then
              echo "- **add-comment**: No issue or PR number available" >> /tmp/validation-errors/add-comment.txt
              VALIDATION_FAILED=true
            fi

            # Phase 2: Execute only if all validations passed
            if [ "$VALIDATION_FAILED" = false ]; then
              echo "âœ“ All add-comment validations passed - executing..."
              for comment_file in $COMMENT_FILES; do
                COMMENT_BODY=$(jq -r '.body' "$comment_file")

                # Append footer with workflow and job information
                FOOTER=$'\n\n> *Generated by workflow [${{ github.workflow }}](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})*'
                COMMENT_BODY_WITH_FOOTER="${COMMENT_BODY}${FOOTER}"

                # Add comment via GitHub API
                gh api "repos/${{ github.repository }}/issues/$ISSUE_NUMBER/comments" \
                  -f body="$COMMENT_BODY_WITH_FOOTER" || {
                  echo "- **add-comment**: Failed to post comment from $comment_file via GitHub API" >> /tmp/validation-errors/add-comment.txt
                }
              done
            else
              echo "âœ— add-comment validation failed - skipping execution (atomic operation)"
            fi
          fi

          fi
      - name: Upload validation results
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: validation-results-${{ matrix.output-type }}
          path: /tmp/validation-errors/
          if-no-files-found: ignore

  report-results:
    runs-on: ubuntu-latest
    needs: execute-outputs
    if: always()
    steps:
      - name: Download all validation results
        uses: actions/download-artifact@v4
        with:
          pattern: validation-results-*
          path: /tmp/all-validation-errors
          merge-multiple: true
        continue-on-error: true
      - name: Generate GitHub token
        id: app-token
        env:
          GH_APP_ID: ${{ secrets.GH_APP_ID }}
          GH_APP_PRIVATE_KEY: ${{ secrets.GH_APP_PRIVATE_KEY }}
          FALLBACK_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |-
          # Check if GitHub App is configured
          if [ -z "$GH_APP_ID" ] || [ -z "$GH_APP_PRIVATE_KEY" ]; then
            echo "No GitHub App configured, using default GITHUB_TOKEN"
            echo "token=$FALLBACK_TOKEN" >> $GITHUB_OUTPUT
            echo "git-user=github-actions[bot]" >> $GITHUB_OUTPUT
            echo "git-email=github-actions[bot]@users.noreply.github.com" >> $GITHUB_OUTPUT
            exit 0
          fi

          echo "GitHub App configured, generating installation token..."

          # Base64 URL-safe encoding function
          base64url() {
            openssl base64 -A | tr '+/' '-_' | tr -d '='
          }

          # Generate JWT header
          HEADER=$(echo -n '{"alg":"RS256","typ":"JWT"}' | base64url)

          # Generate JWT payload (iat = now - 60s to account for clock drift, exp = now + 10 min)
          NOW=$(date +%s)
          IAT=$((NOW - 60))
          EXP=$((NOW + 600))
          PAYLOAD=$(echo -n "{\"iat\":$IAT,\"exp\":$EXP,\"iss\":\"$GH_APP_ID\"}" | base64url)

          # Sign the JWT with the private key
          UNSIGNED="$HEADER.$PAYLOAD"
          SIGNATURE=$(echo -n "$UNSIGNED" | openssl dgst -sha256 -sign <(echo "$GH_APP_PRIVATE_KEY") | base64url)
          JWT="$HEADER.$PAYLOAD.$SIGNATURE"

          # Get installation ID for this repository
          OWNER="${{ github.repository_owner }}"
          REPO_NAME="${{ github.event.repository.name }}"
          INSTALLATION_RESPONSE=$(curl -s -H "Authorization: Bearer $JWT" \
            -H "Accept: application/vnd.github+json" \
            -H "X-GitHub-Api-Version: 2022-11-28" \
            "https://api.github.com/repos/$OWNER/$REPO_NAME/installation")

          INSTALLATION_ID=$(echo "$INSTALLATION_RESPONSE" | jq -r '.id // empty')

          if [ -z "$INSTALLATION_ID" ]; then
            echo "::warning::Failed to get installation ID. Is the GitHub App installed on this repository?"
            echo "::warning::Response: $INSTALLATION_RESPONSE"
            echo "Falling back to GITHUB_TOKEN"
            echo "token=$FALLBACK_TOKEN" >> $GITHUB_OUTPUT
            echo "git-user=github-actions[bot]" >> $GITHUB_OUTPUT
            echo "git-email=github-actions[bot]@users.noreply.github.com" >> $GITHUB_OUTPUT
            exit 0
          fi

          # Generate installation access token
          TOKEN_RESPONSE=$(curl -s -X POST \
            -H "Authorization: Bearer $JWT" \
            -H "Accept: application/vnd.github+json" \
            -H "X-GitHub-Api-Version: 2022-11-28" \
            "https://api.github.com/app/installations/$INSTALLATION_ID/access_tokens")

          TOKEN=$(echo "$TOKEN_RESPONSE" | jq -r '.token // empty')

          if [ -z "$TOKEN" ]; then
            echo "::warning::Failed to generate installation token"
            echo "::warning::Response: $TOKEN_RESPONSE"
            echo "Falling back to GITHUB_TOKEN"
            echo "token=$FALLBACK_TOKEN" >> $GITHUB_OUTPUT
            echo "git-user=github-actions[bot]" >> $GITHUB_OUTPUT
            echo "git-email=github-actions[bot]@users.noreply.github.com" >> $GITHUB_OUTPUT
            exit 0
          fi

          # Mask the token in logs
          echo "::add-mask::$TOKEN"

          # Get app info for git identity
          APP_RESPONSE=$(curl -s -H "Authorization: Bearer $JWT" \
            -H "Accept: application/vnd.github+json" \
            -H "X-GitHub-Api-Version: 2022-11-28" \
            "https://api.github.com/app")

          APP_SLUG=$(echo "$APP_RESPONSE" | jq -r '.slug // "github-app"')
          APP_ID_NUM=$(echo "$APP_RESPONSE" | jq -r '.id // "0"')

          echo "âœ“ Generated GitHub App token for $APP_SLUG"
          echo "token=$TOKEN" >> $GITHUB_OUTPUT
          echo "git-user=$APP_SLUG[bot]" >> $GITHUB_OUTPUT
          echo "git-email=$APP_ID_NUM+$APP_SLUG[bot]@users.noreply.github.com" >> $GITHUB_OUTPUT
      - name: Report validation errors
        env:
          GITHUB_TOKEN: ${{ steps.app-token.outputs.token }}
        run: |

          # Check if there are any validation errors
          if [ -d "/tmp/all-validation-errors" ] && [ "$(ls -A /tmp/all-validation-errors 2>/dev/null)" ]; then
            echo "âš ï¸  Some output validations failed"

            # Build error message
            ERROR_MSG="## âš ï¸ Agent Output Validation Errors\n\nThe following outputs failed validation:\n\n"

            for error_file in /tmp/all-validation-errors/*; do
              if [ -f "$error_file" ]; then
                ERROR_CONTENT=$(cat "$error_file")
                ERROR_MSG="${ERROR_MSG}${ERROR_CONTENT}\n"
              fi
            done

            # Post comment if we have issue/PR number
            ISSUE_OR_PR_NUMBER="${{ github.event.issue.number }}${{ github.event.pull_request.number }}"
            if [ -n "$ISSUE_OR_PR_NUMBER" ]; then
              echo -e "$ERROR_MSG" | gh api "repos/${{ github.repository }}/issues/$ISSUE_OR_PR_NUMBER/comments" \
                -X POST \
                -f body=@- || echo "Failed to post validation error comment"
            else
              echo "No issue or PR number available to post validation errors"
              echo -e "$ERROR_MSG"
            fi

            exit 1
          else
            echo "âœ“ All output validations passed"
          fi

  audit-report:
    runs-on: ubuntu-latest
    needs:
      - pre-flight
      - claude-agent
      - execute-outputs
    if: always()
    steps:
      - name: Download validation audit
        uses: actions/download-artifact@v4
        with:
          name: validation-audit
          path: /tmp/audit-data/validation
        continue-on-error: true
      - name: Download execution metrics
        uses: actions/download-artifact@v4
        with:
          name: audit-metrics
          path: /tmp/audit-data/metrics
        continue-on-error: true
      - name: Download output validation results
        uses: actions/download-artifact@v4
        with:
          pattern: validation-results-*
          path: /tmp/audit-data/outputs
          merge-multiple: true
        continue-on-error: true
      - name: Generate audit report and check status
        id: audit-check
        run: |

          # Check if run was rate-limited (not a failure, just skipped)
          RATE_LIMITED="${{ needs.pre-flight.outputs.rate-limited }}"
          if [ "$RATE_LIMITED" = "true" ]; then
            echo "â­ï¸ Agent run was rate-limited. This is expected behavior, not a failure."
            echo "has-failures=false" >> $GITHUB_OUTPUT
            exit 0
          fi

          # Initialize failure tracking
          HAS_FAILURES="false"
          FAILURE_REASONS=""

          # Check job results
          PRE_FLIGHT_RESULT="${{ needs.pre-flight.result }}"
          CLAUDE_AGENT_RESULT="${{ needs.claude-agent.result }}"
          EXECUTE_OUTPUTS_RESULT="${{ needs.execute-outputs.result }}"

          if [ "$PRE_FLIGHT_RESULT" != "success" ]; then
            HAS_FAILURES="true"
            FAILURE_REASONS="${FAILURE_REASONS}Pre-flight validation failed ($PRE_FLIGHT_RESULT)\n"
          fi

          if [ "$CLAUDE_AGENT_RESULT" != "success" ] && [ "$CLAUDE_AGENT_RESULT" != "skipped" ]; then
            HAS_FAILURES="true"
            FAILURE_REASONS="${FAILURE_REASONS}Claude agent execution failed ($CLAUDE_AGENT_RESULT)\n"
          fi


          if [ "$EXECUTE_OUTPUTS_RESULT" != "success" ] && [ "$EXECUTE_OUTPUTS_RESULT" != "skipped" ]; then
            HAS_FAILURES="true"
            FAILURE_REASONS="${FAILURE_REASONS}Output execution failed ($EXECUTE_OUTPUTS_RESULT)\n"
          fi


          # Check for permission issues
          PERMISSION_ISSUE_COUNT=0
          if [ -f /tmp/audit-data/validation/permission-issues.json ]; then
            PERMISSION_ISSUE_COUNT=$(jq 'length' /tmp/audit-data/validation/permission-issues.json)
            if [ "$PERMISSION_ISSUE_COUNT" -gt 0 ]; then
              HAS_FAILURES="true"
              FAILURE_REASONS="${FAILURE_REASONS}Permission/validation issues detected ($PERMISSION_ISSUE_COUNT)\n"
            fi
          fi

          # Check if Claude had an error
          if [ -f /tmp/audit-data/metrics/metrics.json ]; then
            IS_ERROR=$(jq -r '.is_error // false' /tmp/audit-data/metrics/metrics.json)
            if [ "$IS_ERROR" = "true" ]; then
              HAS_FAILURES="true"
              FAILURE_REASONS="${FAILURE_REASONS}Claude execution returned an error\n"
            fi
          fi

          # Generate the audit report
          mkdir -p /tmp/audit
          cat > /tmp/audit/report.md << 'REPORT_EOF'
          # Agent Execution Audit Report

          **Agent:** Weekly Digest
          **Workflow Run:** [${{ github.run_id }}](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})
          **Triggered by:** @${{ github.actor }}
          **Event:** ${{ github.event_name }}
          **Timestamp:** $(date -u +%Y-%m-%dT%H:%M:%SZ)

          REPORT_EOF

          # Add job results
          echo "## Job Results" >> /tmp/audit/report.md
          echo "" >> /tmp/audit/report.md
          echo "| Job | Result |" >> /tmp/audit/report.md
          echo "|-----|--------|" >> /tmp/audit/report.md
          echo "| pre-flight | $([ \"$PRE_FLIGHT_RESULT\" = \"success\" ] && echo 'âœ…' || echo 'âŒ') $PRE_FLIGHT_RESULT |" >> /tmp/audit/report.md
          echo "| claude-agent | $([ \"$CLAUDE_AGENT_RESULT\" = \"success\" ] && echo 'âœ…' || [ \"$CLAUDE_AGENT_RESULT\" = \"skipped\" ] && echo 'â­ï¸' || echo 'âŒ') $CLAUDE_AGENT_RESULT |" >> /tmp/audit/report.md
          echo "| execute-outputs | $([ \"$EXECUTE_OUTPUTS_RESULT\" = \"success\" ] && echo 'âœ…' || [ \"$EXECUTE_OUTPUTS_RESULT\" = \"skipped\" ] && echo 'â­ï¸' || echo 'âŒ') $EXECUTE_OUTPUTS_RESULT |" >> /tmp/audit/report.md
          echo "" >> /tmp/audit/report.md

          # Add execution metrics if available
          if [ -f /tmp/audit-data/metrics/metrics.json ]; then
            COST=$(jq -r '.total_cost_usd // "N/A"' /tmp/audit-data/metrics/metrics.json)
            TURNS=$(jq -r '.num_turns // "N/A"' /tmp/audit-data/metrics/metrics.json)
            DURATION=$(jq -r '.duration_ms // "N/A"' /tmp/audit-data/metrics/metrics.json)
            SESSION_ID=$(jq -r '.session_id // "N/A"' /tmp/audit-data/metrics/metrics.json)

            echo "## Execution Metrics" >> /tmp/audit/report.md
            echo "" >> /tmp/audit/report.md
            echo "| Metric | Value |" >> /tmp/audit/report.md
            echo "|--------|-------|" >> /tmp/audit/report.md
            echo "| Cost | \$${COST} |" >> /tmp/audit/report.md
            echo "| Turns | ${TURNS} |" >> /tmp/audit/report.md
            echo "| Duration | ${DURATION}ms |" >> /tmp/audit/report.md
            echo "| Session | \`${SESSION_ID}\` |" >> /tmp/audit/report.md
            echo "" >> /tmp/audit/report.md
          fi

          # Add permission issues if any
          if [ "$PERMISSION_ISSUE_COUNT" -gt 0 ]; then
            echo "## Permission Issues" >> /tmp/audit/report.md
            echo "" >> /tmp/audit/report.md
            jq -r '.[] | "- **[\(.severity | ascii_upcase)]** \(.issue_type): \(.message)"' /tmp/audit-data/validation/permission-issues.json >> /tmp/audit/report.md
            echo "" >> /tmp/audit/report.md
          fi

          # Output status for downstream steps
          echo "has-failures=$HAS_FAILURES" >> $GITHUB_OUTPUT
          echo "failure-reasons<<EOF" >> $GITHUB_OUTPUT
          echo -e "$FAILURE_REASONS" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

          # Log summary (quiet mode for success)
          if [ "$HAS_FAILURES" = "true" ]; then
            echo "::error::Agent execution had failures"
            echo ""
            cat /tmp/audit/report.md
          else
            echo "âœ… Agent execution completed successfully"
            echo "ðŸ“Š View full audit report in workflow artifacts"
          fi
      - name: Checkout repository for diagnosis
        if: steps.audit-check.outputs.has-failures == 'true'
        uses: actions/checkout@v4
      - name: Generate GitHub token
        id: app-token
        env:
          GH_APP_ID: ${{ secrets.GH_APP_ID }}
          GH_APP_PRIVATE_KEY: ${{ secrets.GH_APP_PRIVATE_KEY }}
          FALLBACK_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |-
          # Check if GitHub App is configured
          if [ -z "$GH_APP_ID" ] || [ -z "$GH_APP_PRIVATE_KEY" ]; then
            echo "No GitHub App configured, using default GITHUB_TOKEN"
            echo "token=$FALLBACK_TOKEN" >> $GITHUB_OUTPUT
            echo "git-user=github-actions[bot]" >> $GITHUB_OUTPUT
            echo "git-email=github-actions[bot]@users.noreply.github.com" >> $GITHUB_OUTPUT
            exit 0
          fi

          echo "GitHub App configured, generating installation token..."

          # Base64 URL-safe encoding function
          base64url() {
            openssl base64 -A | tr '+/' '-_' | tr -d '='
          }

          # Generate JWT header
          HEADER=$(echo -n '{"alg":"RS256","typ":"JWT"}' | base64url)

          # Generate JWT payload (iat = now - 60s to account for clock drift, exp = now + 10 min)
          NOW=$(date +%s)
          IAT=$((NOW - 60))
          EXP=$((NOW + 600))
          PAYLOAD=$(echo -n "{\"iat\":$IAT,\"exp\":$EXP,\"iss\":\"$GH_APP_ID\"}" | base64url)

          # Sign the JWT with the private key
          UNSIGNED="$HEADER.$PAYLOAD"
          SIGNATURE=$(echo -n "$UNSIGNED" | openssl dgst -sha256 -sign <(echo "$GH_APP_PRIVATE_KEY") | base64url)
          JWT="$HEADER.$PAYLOAD.$SIGNATURE"

          # Get installation ID for this repository
          OWNER="${{ github.repository_owner }}"
          REPO_NAME="${{ github.event.repository.name }}"
          INSTALLATION_RESPONSE=$(curl -s -H "Authorization: Bearer $JWT" \
            -H "Accept: application/vnd.github+json" \
            -H "X-GitHub-Api-Version: 2022-11-28" \
            "https://api.github.com/repos/$OWNER/$REPO_NAME/installation")

          INSTALLATION_ID=$(echo "$INSTALLATION_RESPONSE" | jq -r '.id // empty')

          if [ -z "$INSTALLATION_ID" ]; then
            echo "::warning::Failed to get installation ID. Is the GitHub App installed on this repository?"
            echo "::warning::Response: $INSTALLATION_RESPONSE"
            echo "Falling back to GITHUB_TOKEN"
            echo "token=$FALLBACK_TOKEN" >> $GITHUB_OUTPUT
            echo "git-user=github-actions[bot]" >> $GITHUB_OUTPUT
            echo "git-email=github-actions[bot]@users.noreply.github.com" >> $GITHUB_OUTPUT
            exit 0
          fi

          # Generate installation access token
          TOKEN_RESPONSE=$(curl -s -X POST \
            -H "Authorization: Bearer $JWT" \
            -H "Accept: application/vnd.github+json" \
            -H "X-GitHub-Api-Version: 2022-11-28" \
            "https://api.github.com/app/installations/$INSTALLATION_ID/access_tokens")

          TOKEN=$(echo "$TOKEN_RESPONSE" | jq -r '.token // empty')

          if [ -z "$TOKEN" ]; then
            echo "::warning::Failed to generate installation token"
            echo "::warning::Response: $TOKEN_RESPONSE"
            echo "Falling back to GITHUB_TOKEN"
            echo "token=$FALLBACK_TOKEN" >> $GITHUB_OUTPUT
            echo "git-user=github-actions[bot]" >> $GITHUB_OUTPUT
            echo "git-email=github-actions[bot]@users.noreply.github.com" >> $GITHUB_OUTPUT
            exit 0
          fi

          # Mask the token in logs
          echo "::add-mask::$TOKEN"

          # Get app info for git identity
          APP_RESPONSE=$(curl -s -H "Authorization: Bearer $JWT" \
            -H "Accept: application/vnd.github+json" \
            -H "X-GitHub-Api-Version: 2022-11-28" \
            "https://api.github.com/app")

          APP_SLUG=$(echo "$APP_RESPONSE" | jq -r '.slug // "github-app"')
          APP_ID_NUM=$(echo "$APP_RESPONSE" | jq -r '.id // "0"')

          echo "âœ“ Generated GitHub App token for $APP_SLUG"
          echo "token=$TOKEN" >> $GITHUB_OUTPUT
          echo "git-user=$APP_SLUG[bot]" >> $GITHUB_OUTPUT
          echo "git-email=$APP_ID_NUM+$APP_SLUG[bot]@users.noreply.github.com" >> $GITHUB_OUTPUT
        if: steps.audit-check.outputs.has-failures == 'true'
      - name: Setup Bun for diagnostic agent
        if: steps.audit-check.outputs.has-failures == 'true'
        uses: oven-sh/setup-bun@v2
        with:
          bun-version: latest
      - name: Run safe-mode diagnostic agent
        id: diagnostic
        if: steps.audit-check.outputs.has-failures == 'true'
        env:
          ANTHROPIC_API_KEY: ${{ secrets.ANTHROPIC_API_KEY }}
          CLAUDE_CODE_OAUTH_TOKEN: ${{ secrets.CLAUDE_CODE_OAUTH_TOKEN }}
        run: |

          # Prepare diagnostic context
          cat > /tmp/diagnostic-prompt.md << 'DIAG_EOF'
          You are a diagnostic agent analyzing a failed GitHub Actions workflow for the "Weekly Digest" agent.

          ## Your Task
          Analyze the failure data below and provide:
          1. A clear summary of what went wrong
          2. The root cause analysis
          3. Specific remediation steps the user can take to fix the issue

          ## Failure Information
          ${{ steps.audit-check.outputs.failure-reasons }}

          ## Audit Report
          $(cat /tmp/audit/report.md)

          ## Validation Status
          $(cat /tmp/audit-data/validation/validation-status.json 2>/dev/null || echo "Not available")

          ## Permission Issues
          $(cat /tmp/audit-data/validation/permission-issues.json 2>/dev/null || echo "[]")

          ## Agent Configuration
          - Agent name: Weekly Digest
          - Triggers: {"schedule":[{"cron":"0 10 * * 1"}],"workflow_dispatch":{}}
          - Permissions: {"contents":"read","issues":"read","pull_requests":"read","discussions":"write"}
          - Outputs: ["add-comment"]

          ## Instructions
          Based on the above information:
          1. Write a concise but complete diagnosis
          2. Include specific file paths, configuration changes, or commands needed to fix the issue
          3. If it's a permissions issue, explain exactly what permission is missing and where to add it
          4. If it's a rate limit issue, explain when the user can retry
          5. Format your response in clean markdown suitable for a GitHub issue

          Do NOT use any tools that modify files. You are in read-only diagnostic mode.
          DIAG_EOF

          # Run diagnostic agent in safe mode (read-only tools)
          bunx --bun @anthropic-ai/claude-code \
            -p "$(cat /tmp/diagnostic-prompt.md)" \
            --allowedTools "Read,Glob,Grep" \
            --output-format json > /tmp/diagnostic-output.json 2>&1 || true

          # Extract the diagnosis
          if [ -f /tmp/diagnostic-output.json ]; then
            jq -r '.result // "Unable to generate diagnosis"' /tmp/diagnostic-output.json > /tmp/diagnosis.md
          else
            echo "Diagnostic agent did not produce output. Manual investigation required." > /tmp/diagnosis.md
          fi
      - name: Create failure issue
        if: steps.audit-check.outputs.has-failures == 'true'
        env:
          GITHUB_TOKEN: ${{ steps.app-token.outputs.token }}
        run: |

          # Build issue body
          cat > /tmp/issue-body.md << 'ISSUE_EOF'
          ## ðŸš¨ Agent Failure Report

          The **Weekly Digest** agent encountered failures during execution.

          ### Workflow Details
          - **Run ID:** [${{ github.run_id }}](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})
          - **Triggered by:** @${{ github.actor }}
          - **Event:** ${{ github.event_name }}
          - **Time:** $(date -u +%Y-%m-%dT%H:%M:%SZ)

          ### Failure Summary
          ${{ steps.audit-check.outputs.failure-reasons }}

          ---

          ## ðŸ” Diagnostic Analysis

          $(cat /tmp/diagnosis.md)

          ---

          ## ðŸ“Š Full Audit Report

          <details>
          <summary>Click to expand audit report</summary>

          $(cat /tmp/audit/report.md)

          </details>

          ---

          *This issue was automatically created by the Repo Agents audit system.*
          ISSUE_EOF

          # Check if a similar issue already exists (avoid duplicates)
          EXISTING_ISSUE=$(gh issue list --state open --label "agent-failure" --search "Weekly Digest failure" --json number --jq '.[0].number' 2>/dev/null || echo "")

          if [ -n "$EXISTING_ISSUE" ]; then
            echo "Adding comment to existing issue #$EXISTING_ISSUE"
            gh issue comment "$EXISTING_ISSUE" --body "$(cat /tmp/issue-body.md)"
          else
            echo "Creating new failure issue"
            gh issue create \
              --title "ðŸš¨ Weekly Digest: Agent Execution Failed" \
              --body "$(cat /tmp/issue-body.md)" \
              --label "agent-failure" 
          fi
      - name: Upload audit report
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: audit-report
          path: /tmp/audit/
          if-no-files-found: ignore
permissions:
  contents: read
  issues: read
  pull-requests: read
  discussions: write
