name: Codebase Improver
'on':
  workflow_call:
    inputs:
      context-run-id:
        description: Run ID of the dispatcher workflow (for artifact download)
        required: true
        type: string
jobs:
  pre-flight:
    runs-on: ubuntu-latest
    outputs:
      should-run: ${{ steps.set-output.outputs.should-run || steps.check-rate-limit.outputs.should-run }}
      rate-limited: ${{ steps.check-rate-limit.outputs.rate-limited }}
      app-token: ${{ steps.app-token.outputs.token }}
      git-user: ${{ steps.app-token.outputs.git-user }}
      git-email: ${{ steps.app-token.outputs.git-email }}
    steps:
      - name: Download dispatch context
        uses: actions/download-artifact@v4
        with:
          name: dispatch-context-${{ inputs.context-run-id }}
          path: /tmp/dispatch-context/
          run-id: ${{ inputs.context-run-id }}
          github-token: ${{ secrets.GITHUB_TOKEN }}
      - name: Load dispatch context
        id: load-context
        run: |-
          if [ -f /tmp/dispatch-context/context.json ]; then
            echo "Dispatch context loaded:"
            cat /tmp/dispatch-context/context.json
            # Export context values as outputs
            echo "event-name=$(jq -r '.eventName' /tmp/dispatch-context/context.json)" >> $GITHUB_OUTPUT
            echo "event-action=$(jq -r '.eventAction' /tmp/dispatch-context/context.json)" >> $GITHUB_OUTPUT
          else
            echo "::error::Dispatch context not found"
            exit 1
          fi
      - name: Initialize audit tracking
        id: init-audit
        run: |-
          mkdir -p /tmp/audit
          echo '{
            "secrets_check": true,
            "user_authorization": false,
            "labels_check": false,
            "rate_limit_check": false
          }' > /tmp/audit/validation-status.json
          echo '[]' > /tmp/audit/permission-issues.json
      - name: Generate GitHub token
        id: app-token
        env:
          GH_APP_ID: ${{ secrets.GH_APP_ID }}
          GH_APP_PRIVATE_KEY: ${{ secrets.GH_APP_PRIVATE_KEY }}
          FALLBACK_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |-
          # Check if GitHub App is configured
          if [ -z "$GH_APP_ID" ] || [ -z "$GH_APP_PRIVATE_KEY" ]; then
            echo "No GitHub App configured, using default GITHUB_TOKEN"
            echo "token=$FALLBACK_TOKEN" >> $GITHUB_OUTPUT
            echo "git-user=github-actions[bot]" >> $GITHUB_OUTPUT
            echo "git-email=github-actions[bot]@users.noreply.github.com" >> $GITHUB_OUTPUT
            exit 0
          fi

          echo "GitHub App configured, generating installation token..."

          # Base64 URL-safe encoding function
          base64url() {
            openssl base64 -A | tr '+/' '-_' | tr -d '='
          }

          # Generate JWT header
          HEADER=$(echo -n '{"alg":"RS256","typ":"JWT"}' | base64url)

          # Generate JWT payload (iat = now - 60s to account for clock drift, exp = now + 10 min)
          NOW=$(date +%s)
          IAT=$((NOW - 60))
          EXP=$((NOW + 600))
          PAYLOAD=$(echo -n "{\"iat\":$IAT,\"exp\":$EXP,\"iss\":\"$GH_APP_ID\"}" | base64url)

          # Sign the JWT with the private key
          UNSIGNED="$HEADER.$PAYLOAD"
          SIGNATURE=$(echo -n "$UNSIGNED" | openssl dgst -sha256 -sign <(echo "$GH_APP_PRIVATE_KEY") | base64url)
          JWT="$HEADER.$PAYLOAD.$SIGNATURE"

          # Get installation ID for this repository
          OWNER="${{ github.repository_owner }}"
          REPO_NAME="${{ github.event.repository.name }}"
          INSTALLATION_RESPONSE=$(curl -s -H "Authorization: Bearer $JWT" \
            -H "Accept: application/vnd.github+json" \
            -H "X-GitHub-Api-Version: 2022-11-28" \
            "https://api.github.com/repos/$OWNER/$REPO_NAME/installation")

          INSTALLATION_ID=$(echo "$INSTALLATION_RESPONSE" | jq -r '.id // empty')

          if [ -z "$INSTALLATION_ID" ]; then
            echo "::warning::Failed to get installation ID. Is the GitHub App installed on this repository?"
            echo "::warning::Response: $INSTALLATION_RESPONSE"
            echo "Falling back to GITHUB_TOKEN"
            echo "token=$FALLBACK_TOKEN" >> $GITHUB_OUTPUT
            echo "git-user=github-actions[bot]" >> $GITHUB_OUTPUT
            echo "git-email=github-actions[bot]@users.noreply.github.com" >> $GITHUB_OUTPUT
            exit 0
          fi

          # Generate installation access token
          TOKEN_RESPONSE=$(curl -s -X POST \
            -H "Authorization: Bearer $JWT" \
            -H "Accept: application/vnd.github+json" \
            -H "X-GitHub-Api-Version: 2022-11-28" \
            "https://api.github.com/app/installations/$INSTALLATION_ID/access_tokens")

          TOKEN=$(echo "$TOKEN_RESPONSE" | jq -r '.token // empty')

          if [ -z "$TOKEN" ]; then
            echo "::warning::Failed to generate installation token"
            echo "::warning::Response: $TOKEN_RESPONSE"
            echo "Falling back to GITHUB_TOKEN"
            echo "token=$FALLBACK_TOKEN" >> $GITHUB_OUTPUT
            echo "git-user=github-actions[bot]" >> $GITHUB_OUTPUT
            echo "git-email=github-actions[bot]@users.noreply.github.com" >> $GITHUB_OUTPUT
            exit 0
          fi

          # Mask the token in logs
          echo "::add-mask::$TOKEN"

          # Get app info for git identity
          APP_RESPONSE=$(curl -s -H "Authorization: Bearer $JWT" \
            -H "Accept: application/vnd.github+json" \
            -H "X-GitHub-Api-Version: 2022-11-28" \
            "https://api.github.com/app")

          APP_SLUG=$(echo "$APP_RESPONSE" | jq -r '.slug // "github-app"')
          APP_ID_NUM=$(echo "$APP_RESPONSE" | jq -r '.id // "0"')

          echo "‚úì Generated GitHub App token for $APP_SLUG"
          echo "token=$TOKEN" >> $GITHUB_OUTPUT
          echo "git-user=$APP_SLUG[bot]" >> $GITHUB_OUTPUT
          echo "git-email=$APP_ID_NUM+$APP_SLUG[bot]@users.noreply.github.com" >> $GITHUB_OUTPUT
      - name: Check user authorization
        id: check-user
        env:
          GITHUB_TOKEN: ${{ steps.app-token.outputs.token }}
        run: |-
          ACTOR="${{ github.actor }}"
          ALLOWED_USERS="lucasilverentand"
          ALLOWED_TEAMS=""

          USER_ALLOWED="false"

          # Check explicit user list
          if [ -n "${ALLOWED_USERS}" ]; then
            for user in ${ALLOWED_USERS}; do
              if [ "${ACTOR}" = "${user}" ]; then
                USER_ALLOWED="true"
                echo "‚úì User ${ACTOR} is in allowed users list"
                break
              fi
            done
          fi

          # Check team membership
          if [ "${USER_ALLOWED}" = "false" ] && [ -n "${ALLOWED_TEAMS}" ]; then
            for team in ${ALLOWED_TEAMS}; do
              MEMBERSHIP=$(gh api "orgs/${{ github.repository_owner }}/teams/${team}/memberships/${ACTOR}" --jq '.state' 2>/dev/null || echo "")
              if [ "${MEMBERSHIP}" = "active" ]; then
                USER_ALLOWED="true"
                echo "‚úì User ${ACTOR} is a member of team ${team}"
                break
              fi
            done
          fi

          if [ "${USER_ALLOWED}" = "false" ]; then
            echo "::error::User ${ACTOR} is not authorized to trigger this agent"
            jq '. += [{
              "timestamp": "'$(date -u +%Y-%m-%dT%H:%M:%SZ)'",
              "issue_type": "missing_permission",
              "severity": "error",
              "message": "User not authorized to trigger agent",
              "context": {"user": "'${ACTOR}'"}
            }]' /tmp/audit/permission-issues.json > /tmp/audit/permission-issues.tmp
            mv /tmp/audit/permission-issues.tmp /tmp/audit/permission-issues.json
            echo "validation-failed=true" >> $GITHUB_OUTPUT
            exit 1
          fi

          jq '.user_authorization = true' /tmp/audit/validation-status.json > /tmp/audit/validation-status.tmp
          mv /tmp/audit/validation-status.tmp /tmp/audit/validation-status.json
      - name: Check rate limit
        id: check-rate-limit
        env:
          GITHUB_TOKEN: ${{ steps.app-token.outputs.token }}
        run: |-
          RATE_LIMIT_MINUTES=1

          # Get recent workflow runs for this workflow
          RECENT_RUNS=$(gh api "repos/${{ github.repository }}/actions/runs" \
            --jq "[.workflow_runs[] | select(.name == \"${{ github.workflow }}\" and .status == \"completed\" and .conclusion == \"success\")] | .[0:5] | .[].created_at" 2>/dev/null || echo "")

          if [ -n "${RECENT_RUNS}" ]; then
            CURRENT_TIME=$(date +%s)

            for run_time in ${RECENT_RUNS}; do
              RUN_TIMESTAMP=$(date -d "${run_time}" +%s 2>/dev/null || date -j -f "%Y-%m-%dT%H:%M:%SZ" "${run_time}" +%s 2>/dev/null || echo "0")
              TIME_DIFF=$(( (CURRENT_TIME - RUN_TIMESTAMP) / 60 ))

              if [ "${TIME_DIFF}" -lt "${RATE_LIMIT_MINUTES}" ]; then
                echo "::notice::Rate limit: Agent ran ${TIME_DIFF} minutes ago. Minimum interval is ${RATE_LIMIT_MINUTES} minutes."
                echo "should-run=false" >> $GITHUB_OUTPUT
                echo "rate-limited=true" >> $GITHUB_OUTPUT
                exit 0
              fi
            done
          fi
          echo "‚úì Rate limit check passed"

          jq '.rate_limit_check = true' /tmp/audit/validation-status.json > /tmp/audit/validation-status.tmp
          mv /tmp/audit/validation-status.tmp /tmp/audit/validation-status.json
      - name: Set output
        id: set-output
        run: |-
          echo "should-run=true" >> $GITHUB_OUTPUT
          echo "‚úì All validation checks passed"
      - name: Upload validation audit data
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: validation-audit
          path: /tmp/audit/
          if-no-files-found: ignore

  claude-agent:
    runs-on: ubuntu-latest
    needs: pre-flight
    if: needs.pre-flight.outputs.should-run == 'true'
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
      - name: Download dispatch context
        uses: actions/download-artifact@v4
        with:
          name: dispatch-context-${{ inputs.context-run-id }}
          path: /tmp/dispatch-context/
          run-id: ${{ inputs.context-run-id }}
          github-token: ${{ secrets.GITHUB_TOKEN }}
      - name: Setup Bun
        uses: oven-sh/setup-bun@v2
        with:
          bun-version: latest
      - name: Create outputs directory
        run: mkdir -p /tmp/outputs /tmp/validation-errors
      - name: Prepare context file
        id: prepare
        run: |-
          # Build context from dispatch context artifact
          EVENT_NAME=$(jq -r '.eventName' /tmp/dispatch-context/context.json)
          REPOSITORY=$(jq -r '.repository' /tmp/dispatch-context/context.json)

          cat > /tmp/context.txt << CONTEXT_EOF
          GitHub Event: ${EVENT_NAME}
          Repository: ${REPOSITORY}
          CONTEXT_EOF

          # Add issue context if present
          if jq -e '.issue' /tmp/dispatch-context/context.json > /dev/null 2>&1; then
            ISSUE_NUMBER=$(jq -r '.issue.number' /tmp/dispatch-context/context.json)
            ISSUE_TITLE=$(jq -r '.issue.title' /tmp/dispatch-context/context.json)
            ISSUE_AUTHOR=$(jq -r '.issue.author' /tmp/dispatch-context/context.json)
            ISSUE_BODY=$(jq -r '.issue.body' /tmp/dispatch-context/context.json)

            cat >> /tmp/context.txt << ISSUE_EOF
          Issue #${ISSUE_NUMBER}: ${ISSUE_TITLE}
          Author: @${ISSUE_AUTHOR}
          Body:
          ${ISSUE_BODY}
          ISSUE_EOF
          fi

          # Add PR context if present
          if jq -e '.pullRequest' /tmp/dispatch-context/context.json > /dev/null 2>&1; then
            PR_NUMBER=$(jq -r '.pullRequest.number' /tmp/dispatch-context/context.json)
            PR_TITLE=$(jq -r '.pullRequest.title' /tmp/dispatch-context/context.json)
            PR_AUTHOR=$(jq -r '.pullRequest.author' /tmp/dispatch-context/context.json)
            PR_BODY=$(jq -r '.pullRequest.body' /tmp/dispatch-context/context.json)

            cat >> /tmp/context.txt << PR_EOF
          PR #${PR_NUMBER}: ${PR_TITLE}
          Author: @${PR_AUTHOR}
          Body:
          ${PR_BODY}
          PR_EOF
          fi

          # Add discussion context if present
          if jq -e '.discussion' /tmp/dispatch-context/context.json > /dev/null 2>&1; then
            DISC_NUMBER=$(jq -r '.discussion.number' /tmp/dispatch-context/context.json)
            DISC_TITLE=$(jq -r '.discussion.title' /tmp/dispatch-context/context.json)
            DISC_AUTHOR=$(jq -r '.discussion.author' /tmp/dispatch-context/context.json)
            DISC_BODY=$(jq -r '.discussion.body' /tmp/dispatch-context/context.json)
            DISC_CATEGORY=$(jq -r '.discussion.category' /tmp/dispatch-context/context.json)

            cat >> /tmp/context.txt << DISC_EOF
          Discussion #${DISC_NUMBER}: ${DISC_TITLE}
          Category: ${DISC_CATEGORY}
          Author: @${DISC_AUTHOR}
          Body:
          ${DISC_BODY}
          DISC_EOF
          fi
      - name: Fetch add-label context
        env:
          GITHUB_TOKEN: ${{ needs.pre-flight.outputs.app-token }}
        run: |-
          # Fetch available labels for context
          LABELS_JSON=$(gh api "repos/${{ github.repository }}/labels" --jq '[.[].name]' 2>/dev/null || echo '[]')
          LABELS_LIST=$(echo "$LABELS_JSON" | jq -r 'join(", ")' 2>/dev/null || echo "No labels available")

          cat >> /tmp/context.txt << 'LABELS_EOF'

          ## Available Repository Labels

          The following labels are available in this repository:
          $LABELS_LIST

          **Important**: You can only use labels that already exist. New labels cannot be created by this agent.

          LABELS_EOF
      - name: Create Claude skills file
        run: |-
          mkdir -p .claude && cat > .claude/CLAUDE.md << 'SKILLS_EOF'
          # Agent Output Skills

          This file documents how to create outputs for this agent.

          ## Skill: Create Pull Request

          Create a pull request with code changes.

          **File to create**: \`/tmp/outputs/create-pr.json\`

          **JSON Schema**:
          \`\`\`json
          {
            "branch": "string",
            "title": "string",
            "body": "string",
            "base": "string" (optional),
            "files": [
              {
                "path": "string",
                "content": "string"
              }
            ]
          }
          \`\`\`

          **Fields**:
          - \`branch\` (required): Name for the new branch (e.g., "feature/add-support")
          - \`title\` (required): Clear PR title
          - \`body\` (required): Detailed PR description
          - \`base\` (optional): Target branch. Defaults to repository's default branch.
          - \`files\` (required): Array of files to create/modify
            - \`path\` (required): File path relative to repository root
            - \`content\` (required): Complete file content

          **Constraints**:
          - Maximum PRs: 5
          - Branch name must be valid (no spaces, special chars)
          - Files array must be non-empty


          **Example**:
          Create \`/tmp/outputs/create-pr.json\` with:
          \`\`\`json
          {
            "branch": "feature/fix-validation",
            "title": "Fix: Improve validation logic",
            "body": "## Changes\n\n- Updated validation rules\n- Added tests\n\n## Testing\n\nRan full test suite",
            "base": "main",
            "files": [
              {
                "path": "src/validator.ts",
                "content": "export function validate() { ... }"
              },
              {
                "path": "src/validator.test.ts",
                "content": "describe('validate', () => { ... })"
              }
            ]
          }
          \`\`\`

          **Important**:
          - Use the Write tool to create this file
          - Provide complete file content for each file
          - Branch will be created automatically
          - Commits will be made automatically

          **Multiple PRs**: To create multiple PRs, use numbered files:
          - \`/tmp/outputs/create-pr-1.json\`
          - \`/tmp/outputs/create-pr-2.json\`
          - etc.

          ## Skill: Add Labels

          Add one or more labels to the current issue or pull request.

          **Available labels**: See the "Available Repository Labels" section in the context above for the complete list of labels you can use.

          **File to create**: \`/tmp/outputs/add-label.json\`

          For multiple label operations, use numbered suffixes: \`add-label-1.json\`, \`add-label-2.json\`, etc.

          **JSON Schema**:
          \`\`\`json
          {
            "labels": ["string"]
          }
          \`\`\`

          **Fields**:
          - \`labels\` (required): Array of label names to add

          **Constraints**:
          - Labels must already exist in the repository (see available labels above)
          - Labels array must be non-empty
          - Duplicate labels will be ignored
          - This operation adds to existing labels (doesn't replace them)

          **Example**:
          Create \`/tmp/outputs/add-label.json\` with:
          \`\`\`json
          {
            "labels": ["bug", "priority: high"]
          }
          \`\`\`

          **Important**: Use the Write tool to create this file. Only add labels that exist in the available labels list.

          SKILLS_EOF
      - name: Add agent instructions
        run: |-
          cat >> /tmp/context.txt << 'INSTRUCTIONS_EOF'

          ---

          # Codebase Improvement Agent

          You are an expert software engineer tasked with improving code quality and test coverage in this repository.

          ## MANDATORY ACTION - READ THIS FIRST

          **YOUR PRIMARY TASK IS TO WRITE JSON FILES TO \`/tmp/outputs/\`**

          At the end of this task, you MUST have written at least one file to \`/tmp/outputs/\`. If you do not write any files, the workflow will fail and your analysis will be wasted.

          Use the Write tool like this:
          \`\`\`
          Write to /tmp/outputs/create-pr-1.json with content: {"branch": "...", "title": "...", ...}
          \`\`\`

          DO NOT just analyze and respond with text. You MUST use the Write tool to create output files.

          ---

          ## Your Mission

          Analyze the codebase and create **focused, atomic pull requests** for improvements. Each PR should address ONE specific improvement area to make reviews easier.

          ## Analysis Process

          ### Step 1: Understand the Codebase

          1. Read the project's configuration files (package.json, tsconfig.json, etc.)
          2. Understand the existing test setup and patterns
          3. Identify the tech stack and coding conventions
          4. Review existing tests to understand the testing style used

          ### Step 2: Identify Improvement Opportunities

          #### Testing Improvements
          - **Missing tests**: Functions, modules, or components with no test coverage
          - **Edge cases**: Existing tests that don't cover error paths or boundary conditions
          - **Integration gaps**: Missing integration tests between components
          - **Test quality**: Tests that don't actually assert meaningful behavior

          #### Code Quality Improvements
          - **Dead code**: Unused exports, functions, or variables
          - **Code duplication**: Similar logic that could be consolidated
          - **Type safety**: Places where types could be stricter or better defined
          - **Error handling**: Missing or inadequate error handling
          - **Performance**: Obvious inefficiencies (N+1 patterns, unnecessary re-renders, etc.)

          ### Step 3: Prioritize and Create PRs

          Create PRs in this priority order:
          1. **Critical**: Security issues, broken tests, or bugs
          2. **High**: Missing tests for core functionality
          3. **Medium**: Code quality improvements that reduce complexity
          4. **Low**: Style improvements or minor optimizations

          ## PR Creation Guidelines

          ### Each PR Must:
          - Address **ONE** specific improvement area
          - Have a clear, descriptive title (e.g., "test: add unit tests for parser validation")
          - Include a detailed description explaining:
            - What was improved
            - Why this improvement matters
            - How to verify the changes
          - Follow existing project conventions
          - Pass all existing tests (don't break anything!)

          ### Branch Naming Convention
          Use descriptive branch names:
          - \`improve/test-parser-validation\`
          - \`improve/remove-unused-exports\`
          - \`improve/add-error-handling-api\`

          ### PR Labels
          Add appropriate labels:
          - \`testing\` - for test improvements
          - \`code-quality\` - for refactoring/cleanup
          - \`performance\` - for optimization improvements
          - \`automated\` - always add this to indicate agent-created PR

          ## Constraints

          - **Never modify**: Configuration files, CI/CD workflows, or documentation (unless fixing broken links)
          - **Never add**: New dependencies without explicit approval
          - **Always preserve**: Existing API contracts and public interfaces
          - **Respect**: The \`max_prs\` input parameter (default: 3)
          - **Skip improvements** that would require breaking changes

          ## Focus Areas (based on input)

          Check the \`focus_area\` workflow input:
          - \`all\`: Look at everything (default)
          - \`testing\`: Focus only on test coverage improvements
          - \`code-quality\`: Focus only on code quality/refactoring
          - \`performance\`: Focus only on performance optimizations

          ## Output Format

          First, output a summary of your findings:

          \`\`\`
          ## Analysis Summary

          ### Findings
          - [ ] Finding 1: Brief description
          - [ ] Finding 2: Brief description

          ### PRs to Create
          1. **PR Title** - Brief description of changes
          2. **PR Title** - Brief description of changes

          ### Skipped (and why)
          - Item: Reason it was skipped
          \`\`\`

          ## How to Create PRs

          **IMPORTANT**: You MUST use the skill system to create PRs. Check the CLAUDE.md file in your working directory for the exact JSON schema.

          For each PR you want to create, write a JSON file to \`/tmp/outputs/create-pr.json\` (or \`create-pr-1.json\`, \`create-pr-2.json\` for multiple PRs).

          Example:
          \`\`\`json
          {
            "branch": "improve/add-parser-tests",
            "title": "test: add unit tests for parser edge cases",
            "body": "## Summary\n\nAdds tests for uncovered edge cases in the parser module.\n\n## Changes\n- Added tests for empty input handling\n- Added tests for malformed frontmatter\n\n## Testing\nRun \`npm test\` to verify.",
            "base": "main",
            "files": [
              {
                "path": "src/parser/index.test.ts",
                "content": "// Full file content here..."
              }
            ]
          }
          \`\`\`

          ## Technical Approach

          1. Use \`Glob\` to find files matching patterns (e.g., \`**/*.ts\`)
          2. Use \`Grep\` to search for code patterns
          3. Use \`Read\` to analyze specific files
          4. Use \`Write\` to create output files in \`/tmp/outputs/\`

          ## CRITICAL REQUIREMENTS

          - You MUST create at least one PR if you find ANY improvement opportunity
          - Always write the complete file content in the \`files\` array - not partial diffs
          - The workflow will handle git operations, branch creation, and PR submission automatically
          - If you're unsure whether something is worth a PR, CREATE IT ANYWAY - let the reviewer decide

          Remember: It's better to create a small improvement PR than to create nothing at all.

          ## FINAL REMINDER

          Before finishing, ask yourself:
          1. Did I use the Write tool to create files in \`/tmp/outputs/\`?
          2. Is there at least one \`create-pr-*.json\` file?

          If NO to either question, GO BACK AND CREATE THE OUTPUT FILES NOW using the Write tool.
          INSTRUCTIONS_EOF
      - name: Install Claude Code CLI
        run: bunx --bun @anthropic-ai/claude-code --version
      - name: Run Claude Agent
        id: run-claude
        env:
          ANTHROPIC_API_KEY: ${{ secrets.ANTHROPIC_API_KEY }}
          CLAUDE_CODE_OAUTH_TOKEN: ${{ secrets.CLAUDE_CODE_OAUTH_TOKEN }}
          GITHUB_TOKEN: ${{ steps.app-token.outputs.token }}
          GH_TOKEN: ${{ steps.app-token.outputs.token }}
        run: bunx --bun @anthropic-ai/claude-code -p "$(cat /tmp/context.txt)" --allowedTools "Write(/tmp/outputs/*),Read,Glob,Grep" --permission-mode bypassPermissions --output-format json > /tmp/claude-output.json
      - name: Extract execution metrics
        id: extract-metrics
        if: always()
        run: |-
          if [ -f /tmp/claude-output.json ]; then
            echo "=== Claude Execution Summary ==="

            # Extract metrics using jq
            COST=$(jq -r '.total_cost_usd // "N/A"' /tmp/claude-output.json)
            TURNS=$(jq -r '.num_turns // "N/A"' /tmp/claude-output.json)
            DURATION=$(jq -r '.duration_ms // "N/A"' /tmp/claude-output.json)
            IS_ERROR=$(jq -r '.is_error // false' /tmp/claude-output.json)

            echo "Cost: \$${COST}"
            echo "Turns: ${TURNS}"
            echo "Duration: ${DURATION}ms"
            echo "Error: ${IS_ERROR}"

            # Set outputs for downstream jobs
            echo "cost=${COST}" >> $GITHUB_OUTPUT
            echo "turns=${TURNS}" >> $GITHUB_OUTPUT
            echo "duration=${DURATION}" >> $GITHUB_OUTPUT
            echo "is-error=${IS_ERROR}" >> $GITHUB_OUTPUT

            if [ "${IS_ERROR}" = "true" ]; then
              echo "claude-error=true" >> $GITHUB_OUTPUT
              echo "::warning::Claude execution completed with errors"
            fi
          else
            echo "::warning::Claude output file not found"
            echo "cost=N/A" >> $GITHUB_OUTPUT
            echo "turns=N/A" >> $GITHUB_OUTPUT
            echo "duration=N/A" >> $GITHUB_OUTPUT
            echo "is-error=true" >> $GITHUB_OUTPUT
            echo "claude-error=true" >> $GITHUB_OUTPUT
          fi
      - name: Upload outputs
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: claude-outputs
          path: /tmp/outputs/
          if-no-files-found: ignore
      - name: Upload Claude execution data
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: claude-execution
          path: /tmp/claude-output.json
          if-no-files-found: ignore

  execute-outputs:
    runs-on: ubuntu-latest
    needs: claude-agent
    if: success() && needs.claude-agent.result == 'success'
    strategy:
      matrix:
        output-type:
          - create-pr
          - add-label
      fail-fast: false
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
      - name: Generate GitHub token
        id: app-token
        env:
          GH_APP_ID: ${{ secrets.GH_APP_ID }}
          GH_APP_PRIVATE_KEY: ${{ secrets.GH_APP_PRIVATE_KEY }}
          FALLBACK_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |-
          # Check if GitHub App is configured
          if [ -z "$GH_APP_ID" ] || [ -z "$GH_APP_PRIVATE_KEY" ]; then
            echo "No GitHub App configured, using default GITHUB_TOKEN"
            echo "token=$FALLBACK_TOKEN" >> $GITHUB_OUTPUT
            echo "git-user=github-actions[bot]" >> $GITHUB_OUTPUT
            echo "git-email=github-actions[bot]@users.noreply.github.com" >> $GITHUB_OUTPUT
            exit 0
          fi

          echo "GitHub App configured, generating installation token..."

          # Base64 URL-safe encoding function
          base64url() {
            openssl base64 -A | tr '+/' '-_' | tr -d '='
          }

          # Generate JWT header
          HEADER=$(echo -n '{"alg":"RS256","typ":"JWT"}' | base64url)

          # Generate JWT payload (iat = now - 60s to account for clock drift, exp = now + 10 min)
          NOW=$(date +%s)
          IAT=$((NOW - 60))
          EXP=$((NOW + 600))
          PAYLOAD=$(echo -n "{\"iat\":$IAT,\"exp\":$EXP,\"iss\":\"$GH_APP_ID\"}" | base64url)

          # Sign the JWT with the private key
          UNSIGNED="$HEADER.$PAYLOAD"
          SIGNATURE=$(echo -n "$UNSIGNED" | openssl dgst -sha256 -sign <(echo "$GH_APP_PRIVATE_KEY") | base64url)
          JWT="$HEADER.$PAYLOAD.$SIGNATURE"

          # Get installation ID for this repository
          OWNER="${{ github.repository_owner }}"
          REPO_NAME="${{ github.event.repository.name }}"
          INSTALLATION_RESPONSE=$(curl -s -H "Authorization: Bearer $JWT" \
            -H "Accept: application/vnd.github+json" \
            -H "X-GitHub-Api-Version: 2022-11-28" \
            "https://api.github.com/repos/$OWNER/$REPO_NAME/installation")

          INSTALLATION_ID=$(echo "$INSTALLATION_RESPONSE" | jq -r '.id // empty')

          if [ -z "$INSTALLATION_ID" ]; then
            echo "::warning::Failed to get installation ID. Is the GitHub App installed on this repository?"
            echo "::warning::Response: $INSTALLATION_RESPONSE"
            echo "Falling back to GITHUB_TOKEN"
            echo "token=$FALLBACK_TOKEN" >> $GITHUB_OUTPUT
            echo "git-user=github-actions[bot]" >> $GITHUB_OUTPUT
            echo "git-email=github-actions[bot]@users.noreply.github.com" >> $GITHUB_OUTPUT
            exit 0
          fi

          # Generate installation access token
          TOKEN_RESPONSE=$(curl -s -X POST \
            -H "Authorization: Bearer $JWT" \
            -H "Accept: application/vnd.github+json" \
            -H "X-GitHub-Api-Version: 2022-11-28" \
            "https://api.github.com/app/installations/$INSTALLATION_ID/access_tokens")

          TOKEN=$(echo "$TOKEN_RESPONSE" | jq -r '.token // empty')

          if [ -z "$TOKEN" ]; then
            echo "::warning::Failed to generate installation token"
            echo "::warning::Response: $TOKEN_RESPONSE"
            echo "Falling back to GITHUB_TOKEN"
            echo "token=$FALLBACK_TOKEN" >> $GITHUB_OUTPUT
            echo "git-user=github-actions[bot]" >> $GITHUB_OUTPUT
            echo "git-email=github-actions[bot]@users.noreply.github.com" >> $GITHUB_OUTPUT
            exit 0
          fi

          # Mask the token in logs
          echo "::add-mask::$TOKEN"

          # Get app info for git identity
          APP_RESPONSE=$(curl -s -H "Authorization: Bearer $JWT" \
            -H "Accept: application/vnd.github+json" \
            -H "X-GitHub-Api-Version: 2022-11-28" \
            "https://api.github.com/app")

          APP_SLUG=$(echo "$APP_RESPONSE" | jq -r '.slug // "github-app"')
          APP_ID_NUM=$(echo "$APP_RESPONSE" | jq -r '.id // "0"')

          echo "‚úì Generated GitHub App token for $APP_SLUG"
          echo "token=$TOKEN" >> $GITHUB_OUTPUT
          echo "git-user=$APP_SLUG[bot]" >> $GITHUB_OUTPUT
          echo "git-email=$APP_ID_NUM+$APP_SLUG[bot]@users.noreply.github.com" >> $GITHUB_OUTPUT
      - name: Download outputs artifact
        uses: actions/download-artifact@v4
        with:
          name: agent-outputs
          path: /tmp/outputs
        continue-on-error: true
      - name: Create validation errors directory
        run: mkdir -p /tmp/validation-errors
      - name: Validate and execute ${{ matrix.output-type }}
        env:
          GITHUB_TOKEN: ${{ steps.app-token.outputs.token }}
          GIT_USER: ${{ steps.app-token.outputs.git-user }}
          GIT_EMAIL: ${{ steps.app-token.outputs.git-email }}
        run: |

          if [ "${{ matrix.output-type }}" = "create-pr" ]; then

          # Validate and execute create-pr output(s)
          # Find all create-pr JSON files (create-pr.json, create-pr-1.json, create-pr-2.json, etc.)
          PR_FILES=$(find /tmp/outputs -name "create-pr*.json" 2>/dev/null | sort || true)

          if [ -n "$PR_FILES" ]; then
            PR_COUNT=0
            MAX_PRS=5

            for PR_FILE in $PR_FILES; do
              if [ $PR_COUNT -ge $MAX_PRS ]; then
                echo "‚ö†Ô∏è Reached maximum PR limit ($MAX_PRS), skipping remaining files"
                break
              fi

              PR_NAME=$(basename "$PR_FILE" .json)
              echo "Processing $PR_NAME..."

              # Validate JSON structure
              if ! jq empty "$PR_FILE" 2>/dev/null; then
                echo "- **$PR_NAME**: Invalid JSON format" >> /tmp/validation-errors/create-pr.txt
                continue
              fi

              # Extract fields
              BRANCH=$(jq -r '.branch' "$PR_FILE")
              TITLE=$(jq -r '.title' "$PR_FILE")
              BODY=$(jq -r '.body' "$PR_FILE")
              BASE=$(jq -r '.base // "main"' "$PR_FILE")
              FILES=$(jq -r '.files' "$PR_FILE")

              # Validate required fields
              if [ -z "$BRANCH" ] || [ "$BRANCH" = "null" ]; then
                echo "- **$PR_NAME**: branch is required" >> /tmp/validation-errors/create-pr.txt
                continue
              elif [ -z "$TITLE" ] || [ "$TITLE" = "null" ]; then
                echo "- **$PR_NAME**: title is required" >> /tmp/validation-errors/create-pr.txt
                continue
              elif [ -z "$BODY" ] || [ "$BODY" = "null" ]; then
                echo "- **$PR_NAME**: body is required" >> /tmp/validation-errors/create-pr.txt
                continue
              elif [ "$FILES" = "null" ] || ! echo "$FILES" | jq -e 'type == "array"' >/dev/null 2>&1; then
                echo "- **$PR_NAME**: files field must be an array" >> /tmp/validation-errors/create-pr.txt
                continue
              elif [ "$(echo "$FILES" | jq 'length')" -eq 0 ]; then
                echo "- **$PR_NAME**: files array cannot be empty" >> /tmp/validation-errors/create-pr.txt
                continue
              elif [[ ! "$BRANCH" =~ ^[a-zA-Z0-9/_.-]+$ ]]; then
                echo "- **$PR_NAME**: branch name contains invalid characters" >> /tmp/validation-errors/create-pr.txt
                continue
              fi

              # Validation passed - execute
              echo "‚úì $PR_NAME validation passed"

              # Configure git with dynamic identity (from GitHub App or default)
              git config user.name "${GIT_USER:-github-actions[bot]}"
              git config user.email "${GIT_EMAIL:-github-actions[bot]@users.noreply.github.com}"

              # Return to main branch before creating new branch
              git checkout main 2>/dev/null || git checkout master 2>/dev/null || true

              # Check if PR already exists for this branch
              if gh pr view "$BRANCH" --json state --jq '.state' 2>/dev/null | grep -q "OPEN"; then
                echo "‚è≠Ô∏è PR already exists for branch '$BRANCH', skipping"
                continue
              fi

              # Delete existing remote branch if it exists (from previous failed attempts)
              if git ls-remote --exit-code --heads origin "$BRANCH" >/dev/null 2>&1; then
                echo "üóëÔ∏è Deleting existing remote branch '$BRANCH'"
                git push origin --delete "$BRANCH" 2>/dev/null || true
              fi

              # Delete local branch if it exists
              git branch -D "$BRANCH" 2>/dev/null || true

              # Create and checkout new branch
              if ! git checkout -b "$BRANCH" 2>/dev/null; then
                echo "- **$PR_NAME**: Failed to create branch '$BRANCH'" >> /tmp/validation-errors/create-pr.txt
                continue
              fi

              # Create/update each file using jq to extract paths and contents safely
              FILE_COUNT=$(jq '.files | length' "$PR_FILE")
              for i in $(seq 0 $((FILE_COUNT - 1))); do
                FILE_PATH=$(jq -r ".files[$i].path" "$PR_FILE")

                # Create directory if needed
                mkdir -p "$(dirname "$FILE_PATH")"

                # Write file content directly using jq (handles special chars properly)
                jq -r ".files[$i].content" "$PR_FILE" > "$FILE_PATH"

                # Stage file
                git add "$FILE_PATH"
              done

              # Commit changes
              COMMIT_MESSAGE="$TITLE"
              git commit -m "$COMMIT_MESSAGE" || {
                echo "- **$PR_NAME**: Failed to commit changes" >> /tmp/validation-errors/create-pr.txt
                git checkout main 2>/dev/null || git checkout master 2>/dev/null || true
                continue
              }

              # Push branch
              git push origin "$BRANCH" || {
                echo "- **$PR_NAME**: Failed to push branch to remote" >> /tmp/validation-errors/create-pr.txt
                git checkout main 2>/dev/null || git checkout master 2>/dev/null || true
                continue
              }

              # Create pull request
              gh pr create \
                --title "$TITLE" \
                --body "$BODY" \
                --base "$BASE" \
                --head "$BRANCH" && {
                echo "‚úÖ Created PR: $TITLE"
                PR_COUNT=$((PR_COUNT + 1))
              } || {
                echo "- **$PR_NAME**: Failed to create pull request via GitHub API" >> /tmp/validation-errors/create-pr.txt
              }

              # Return to main branch for next PR
              git checkout main 2>/dev/null || git checkout master 2>/dev/null || true
            done

            echo "üìä Created $PR_COUNT PRs"
          fi

          fi


          if [ "${{ matrix.output-type }}" = "add-label" ]; then

          # Validate and execute add-label output(s)
          LABEL_FILES=$(find /tmp/outputs -name "add-label*.json" 2>/dev/null || true)

          if [ -n "$LABEL_FILES" ]; then
            FILE_COUNT=$(echo "$LABEL_FILES" | wc -l)
            echo "Found $FILE_COUNT add-label output file(s)"

            # Phase 1: Validate all files
            VALIDATION_FAILED=false
            ALL_LABELS="[]"
            INVALID_LABELS=""

            # Fetch existing labels from repository
            EXISTING_LABELS=$(gh api "repos/${{ github.repository }}/labels" --jq '[.[].name]' 2>/dev/null || echo '[]')

            # Validate each file
            for label_file in $LABEL_FILES; do
              echo "Validating $label_file..."

              # Validate JSON structure
              if ! jq empty "$label_file" 2>/dev/null; then
                echo "- **add-label**: Invalid JSON format in $label_file" >> /tmp/validation-errors/add-label.txt
                VALIDATION_FAILED=true
                continue
              fi

              # Extract labels array
              LABELS_ARRAY=$(jq -r '.labels' "$label_file" 2>/dev/null)

              # Validate labels is an array
              if [ "$LABELS_ARRAY" = "null" ] || ! echo "$LABELS_ARRAY" | jq -e 'type == "array"' >/dev/null 2>&1; then
                echo "- **add-label**: labels field must be an array in $label_file" >> /tmp/validation-errors/add-label.txt
                VALIDATION_FAILED=true
                continue
              elif [ "$(echo "$LABELS_ARRAY" | jq 'length')" -eq 0 ]; then
                echo "- **add-label**: labels array cannot be empty in $label_file" >> /tmp/validation-errors/add-label.txt
                VALIDATION_FAILED=true
                continue
              fi

              # Validate each label exists
              for label in $(echo "$LABELS_ARRAY" | jq -r '.[]'); do
                if ! echo "$EXISTING_LABELS" | jq -e --arg label "$label" 'index($label)' >/dev/null 2>&1; then
                  if [ -z "$INVALID_LABELS" ]; then
                    INVALID_LABELS="$label"
                  else
                    INVALID_LABELS="$INVALID_LABELS, $label"
                  fi
                  VALIDATION_FAILED=true
                fi
              done

              # Merge labels
              ALL_LABELS=$(echo "$ALL_LABELS" "$LABELS_ARRAY" | jq -s 'add | unique')
              echo "‚úì Validation passed for $label_file"
            done

            # Write error if there are invalid labels
            if [ -n "$INVALID_LABELS" ]; then
              echo "- **add-label**: The following labels do not exist in the repository: $INVALID_LABELS" >> /tmp/validation-errors/add-label.txt
            fi

            # Check if we have an issue/PR number
            ISSUE_NUMBER="${{ github.event.issue.number }}${{ github.event.pull_request.number }}"
            if [ -z "$ISSUE_NUMBER" ]; then
              echo "- **add-label**: No issue or PR number available" >> /tmp/validation-errors/add-label.txt
              VALIDATION_FAILED=true
            fi

            # Check if we have any labels to add
            if [ "$(echo "$ALL_LABELS" | jq 'length')" -eq 0 ]; then
              echo "- **add-label**: No valid labels to add" >> /tmp/validation-errors/add-label.txt
              VALIDATION_FAILED=true
            fi

            # Phase 2: Execute only if all validations passed
            if [ "$VALIDATION_FAILED" = false ]; then
              echo "‚úì All add-label validations passed - executing..."

              # Get current labels and merge with new ones to avoid overwriting
              CURRENT_LABELS=$(gh api "repos/${{ github.repository }}/issues/$ISSUE_NUMBER" --jq '.labels[].name' 2>/dev/null | jq -R . | jq -s .)
              MERGED_LABELS=$(echo "$CURRENT_LABELS" "$ALL_LABELS" | jq -s 'add | unique')

              # Add labels via GitHub API
              echo "$MERGED_LABELS" | gh api "repos/${{ github.repository }}/issues/$ISSUE_NUMBER/labels" \
                -X PUT \
                --input - || {
                echo "- **add-label**: Failed to add labels via GitHub API" >> /tmp/validation-errors/add-label.txt
              }
            else
              echo "‚úó add-label validation failed - skipping execution (atomic operation)"
            fi
          fi

          fi
      - name: Upload validation results
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: validation-results-${{ matrix.output-type }}
          path: /tmp/validation-errors/
          if-no-files-found: ignore

  report-results:
    runs-on: ubuntu-latest
    needs: execute-outputs
    if: always()
    steps:
      - name: Download all validation results
        uses: actions/download-artifact@v4
        with:
          pattern: validation-results-*
          path: /tmp/all-validation-errors
          merge-multiple: true
        continue-on-error: true
      - name: Generate GitHub token
        id: app-token
        env:
          GH_APP_ID: ${{ secrets.GH_APP_ID }}
          GH_APP_PRIVATE_KEY: ${{ secrets.GH_APP_PRIVATE_KEY }}
          FALLBACK_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |-
          # Check if GitHub App is configured
          if [ -z "$GH_APP_ID" ] || [ -z "$GH_APP_PRIVATE_KEY" ]; then
            echo "No GitHub App configured, using default GITHUB_TOKEN"
            echo "token=$FALLBACK_TOKEN" >> $GITHUB_OUTPUT
            echo "git-user=github-actions[bot]" >> $GITHUB_OUTPUT
            echo "git-email=github-actions[bot]@users.noreply.github.com" >> $GITHUB_OUTPUT
            exit 0
          fi

          echo "GitHub App configured, generating installation token..."

          # Base64 URL-safe encoding function
          base64url() {
            openssl base64 -A | tr '+/' '-_' | tr -d '='
          }

          # Generate JWT header
          HEADER=$(echo -n '{"alg":"RS256","typ":"JWT"}' | base64url)

          # Generate JWT payload (iat = now - 60s to account for clock drift, exp = now + 10 min)
          NOW=$(date +%s)
          IAT=$((NOW - 60))
          EXP=$((NOW + 600))
          PAYLOAD=$(echo -n "{\"iat\":$IAT,\"exp\":$EXP,\"iss\":\"$GH_APP_ID\"}" | base64url)

          # Sign the JWT with the private key
          UNSIGNED="$HEADER.$PAYLOAD"
          SIGNATURE=$(echo -n "$UNSIGNED" | openssl dgst -sha256 -sign <(echo "$GH_APP_PRIVATE_KEY") | base64url)
          JWT="$HEADER.$PAYLOAD.$SIGNATURE"

          # Get installation ID for this repository
          OWNER="${{ github.repository_owner }}"
          REPO_NAME="${{ github.event.repository.name }}"
          INSTALLATION_RESPONSE=$(curl -s -H "Authorization: Bearer $JWT" \
            -H "Accept: application/vnd.github+json" \
            -H "X-GitHub-Api-Version: 2022-11-28" \
            "https://api.github.com/repos/$OWNER/$REPO_NAME/installation")

          INSTALLATION_ID=$(echo "$INSTALLATION_RESPONSE" | jq -r '.id // empty')

          if [ -z "$INSTALLATION_ID" ]; then
            echo "::warning::Failed to get installation ID. Is the GitHub App installed on this repository?"
            echo "::warning::Response: $INSTALLATION_RESPONSE"
            echo "Falling back to GITHUB_TOKEN"
            echo "token=$FALLBACK_TOKEN" >> $GITHUB_OUTPUT
            echo "git-user=github-actions[bot]" >> $GITHUB_OUTPUT
            echo "git-email=github-actions[bot]@users.noreply.github.com" >> $GITHUB_OUTPUT
            exit 0
          fi

          # Generate installation access token
          TOKEN_RESPONSE=$(curl -s -X POST \
            -H "Authorization: Bearer $JWT" \
            -H "Accept: application/vnd.github+json" \
            -H "X-GitHub-Api-Version: 2022-11-28" \
            "https://api.github.com/app/installations/$INSTALLATION_ID/access_tokens")

          TOKEN=$(echo "$TOKEN_RESPONSE" | jq -r '.token // empty')

          if [ -z "$TOKEN" ]; then
            echo "::warning::Failed to generate installation token"
            echo "::warning::Response: $TOKEN_RESPONSE"
            echo "Falling back to GITHUB_TOKEN"
            echo "token=$FALLBACK_TOKEN" >> $GITHUB_OUTPUT
            echo "git-user=github-actions[bot]" >> $GITHUB_OUTPUT
            echo "git-email=github-actions[bot]@users.noreply.github.com" >> $GITHUB_OUTPUT
            exit 0
          fi

          # Mask the token in logs
          echo "::add-mask::$TOKEN"

          # Get app info for git identity
          APP_RESPONSE=$(curl -s -H "Authorization: Bearer $JWT" \
            -H "Accept: application/vnd.github+json" \
            -H "X-GitHub-Api-Version: 2022-11-28" \
            "https://api.github.com/app")

          APP_SLUG=$(echo "$APP_RESPONSE" | jq -r '.slug // "github-app"')
          APP_ID_NUM=$(echo "$APP_RESPONSE" | jq -r '.id // "0"')

          echo "‚úì Generated GitHub App token for $APP_SLUG"
          echo "token=$TOKEN" >> $GITHUB_OUTPUT
          echo "git-user=$APP_SLUG[bot]" >> $GITHUB_OUTPUT
          echo "git-email=$APP_ID_NUM+$APP_SLUG[bot]@users.noreply.github.com" >> $GITHUB_OUTPUT
      - name: Report validation errors
        env:
          GITHUB_TOKEN: ${{ steps.app-token.outputs.token }}
        run: |

          # Check if there are any validation errors
          if [ -d "/tmp/all-validation-errors" ] && [ "$(ls -A /tmp/all-validation-errors 2>/dev/null)" ]; then
            echo "‚ö†Ô∏è  Some output validations failed"

            # Build error message
            ERROR_MSG="## ‚ö†Ô∏è Agent Output Validation Errors\n\nThe following outputs failed validation:\n\n"

            for error_file in /tmp/all-validation-errors/*; do
              if [ -f "$error_file" ]; then
                ERROR_CONTENT=$(cat "$error_file")
                ERROR_MSG="${ERROR_MSG}${ERROR_CONTENT}\n"
              fi
            done

            # Post comment if we have issue/PR number
            ISSUE_OR_PR_NUMBER="${{ github.event.issue.number }}${{ github.event.pull_request.number }}"
            if [ -n "$ISSUE_OR_PR_NUMBER" ]; then
              echo -e "$ERROR_MSG" | gh api "repos/${{ github.repository }}/issues/$ISSUE_OR_PR_NUMBER/comments" \
                -X POST \
                -f body=@- || echo "Failed to post validation error comment"
            else
              echo "No issue or PR number available to post validation errors"
              echo -e "$ERROR_MSG"
            fi

            exit 1
          else
            echo "‚úì All output validations passed"
          fi

  audit-report:
    runs-on: ubuntu-latest
    needs:
      - pre-flight
      - claude-agent
      - execute-outputs
    if: always()
    steps:
      - name: Download validation audit
        uses: actions/download-artifact@v4
        with:
          name: validation-audit
          path: /tmp/audit-data/validation
        continue-on-error: true
      - name: Download execution metrics
        uses: actions/download-artifact@v4
        with:
          name: audit-metrics
          path: /tmp/audit-data/metrics
        continue-on-error: true
      - name: Download output validation results
        uses: actions/download-artifact@v4
        with:
          pattern: validation-results-*
          path: /tmp/audit-data/outputs
          merge-multiple: true
        continue-on-error: true
      - name: Generate audit report and check status
        id: audit-check
        run: |

          # Check if run was rate-limited (not a failure, just skipped)
          RATE_LIMITED="${{ needs.pre-flight.outputs.rate-limited }}"
          if [ "$RATE_LIMITED" = "true" ]; then
            echo "‚è≠Ô∏è Agent run was rate-limited. This is expected behavior, not a failure."
            echo "has-failures=false" >> $GITHUB_OUTPUT
            exit 0
          fi

          # Initialize failure tracking
          HAS_FAILURES="false"
          FAILURE_REASONS=""

          # Check job results
          PRE_FLIGHT_RESULT="${{ needs.pre-flight.result }}"
          CLAUDE_AGENT_RESULT="${{ needs.claude-agent.result }}"
          EXECUTE_OUTPUTS_RESULT="${{ needs.execute-outputs.result }}"

          if [ "$PRE_FLIGHT_RESULT" != "success" ]; then
            HAS_FAILURES="true"
            FAILURE_REASONS="${FAILURE_REASONS}Pre-flight validation failed ($PRE_FLIGHT_RESULT)\n"
          fi

          if [ "$CLAUDE_AGENT_RESULT" != "success" ] && [ "$CLAUDE_AGENT_RESULT" != "skipped" ]; then
            HAS_FAILURES="true"
            FAILURE_REASONS="${FAILURE_REASONS}Claude agent execution failed ($CLAUDE_AGENT_RESULT)\n"
          fi


          if [ "$EXECUTE_OUTPUTS_RESULT" != "success" ] && [ "$EXECUTE_OUTPUTS_RESULT" != "skipped" ]; then
            HAS_FAILURES="true"
            FAILURE_REASONS="${FAILURE_REASONS}Output execution failed ($EXECUTE_OUTPUTS_RESULT)\n"
          fi


          # Check for permission issues
          PERMISSION_ISSUE_COUNT=0
          if [ -f /tmp/audit-data/validation/permission-issues.json ]; then
            PERMISSION_ISSUE_COUNT=$(jq 'length' /tmp/audit-data/validation/permission-issues.json)
            if [ "$PERMISSION_ISSUE_COUNT" -gt 0 ]; then
              HAS_FAILURES="true"
              FAILURE_REASONS="${FAILURE_REASONS}Permission/validation issues detected ($PERMISSION_ISSUE_COUNT)\n"
            fi
          fi

          # Check if Claude had an error
          if [ -f /tmp/audit-data/metrics/metrics.json ]; then
            IS_ERROR=$(jq -r '.is_error // false' /tmp/audit-data/metrics/metrics.json)
            if [ "$IS_ERROR" = "true" ]; then
              HAS_FAILURES="true"
              FAILURE_REASONS="${FAILURE_REASONS}Claude execution returned an error\n"
            fi
          fi

          # Generate the audit report
          mkdir -p /tmp/audit
          cat > /tmp/audit/report.md << 'REPORT_EOF'
          # Agent Execution Audit Report

          **Agent:** Codebase Improver
          **Workflow Run:** [${{ github.run_id }}](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})
          **Triggered by:** @${{ github.actor }}
          **Event:** ${{ github.event_name }}
          **Timestamp:** $(date -u +%Y-%m-%dT%H:%M:%SZ)

          REPORT_EOF

          # Add job results
          echo "## Job Results" >> /tmp/audit/report.md
          echo "" >> /tmp/audit/report.md
          echo "| Job | Result |" >> /tmp/audit/report.md
          echo "|-----|--------|" >> /tmp/audit/report.md
          echo "| pre-flight | $([ \"$PRE_FLIGHT_RESULT\" = \"success\" ] && echo '‚úÖ' || echo '‚ùå') $PRE_FLIGHT_RESULT |" >> /tmp/audit/report.md
          echo "| claude-agent | $([ \"$CLAUDE_AGENT_RESULT\" = \"success\" ] && echo '‚úÖ' || [ \"$CLAUDE_AGENT_RESULT\" = \"skipped\" ] && echo '‚è≠Ô∏è' || echo '‚ùå') $CLAUDE_AGENT_RESULT |" >> /tmp/audit/report.md
          echo "| execute-outputs | $([ \"$EXECUTE_OUTPUTS_RESULT\" = \"success\" ] && echo '‚úÖ' || [ \"$EXECUTE_OUTPUTS_RESULT\" = \"skipped\" ] && echo '‚è≠Ô∏è' || echo '‚ùå') $EXECUTE_OUTPUTS_RESULT |" >> /tmp/audit/report.md
          echo "" >> /tmp/audit/report.md

          # Add execution metrics if available
          if [ -f /tmp/audit-data/metrics/metrics.json ]; then
            COST=$(jq -r '.total_cost_usd // "N/A"' /tmp/audit-data/metrics/metrics.json)
            TURNS=$(jq -r '.num_turns // "N/A"' /tmp/audit-data/metrics/metrics.json)
            DURATION=$(jq -r '.duration_ms // "N/A"' /tmp/audit-data/metrics/metrics.json)
            SESSION_ID=$(jq -r '.session_id // "N/A"' /tmp/audit-data/metrics/metrics.json)

            echo "## Execution Metrics" >> /tmp/audit/report.md
            echo "" >> /tmp/audit/report.md
            echo "| Metric | Value |" >> /tmp/audit/report.md
            echo "|--------|-------|" >> /tmp/audit/report.md
            echo "| Cost | \$${COST} |" >> /tmp/audit/report.md
            echo "| Turns | ${TURNS} |" >> /tmp/audit/report.md
            echo "| Duration | ${DURATION}ms |" >> /tmp/audit/report.md
            echo "| Session | \`${SESSION_ID}\` |" >> /tmp/audit/report.md
            echo "" >> /tmp/audit/report.md
          fi

          # Add permission issues if any
          if [ "$PERMISSION_ISSUE_COUNT" -gt 0 ]; then
            echo "## Permission Issues" >> /tmp/audit/report.md
            echo "" >> /tmp/audit/report.md
            jq -r '.[] | "- **[\(.severity | ascii_upcase)]** \(.issue_type): \(.message)"' /tmp/audit-data/validation/permission-issues.json >> /tmp/audit/report.md
            echo "" >> /tmp/audit/report.md
          fi

          # Output status for downstream steps
          echo "has-failures=$HAS_FAILURES" >> $GITHUB_OUTPUT
          echo "failure-reasons<<EOF" >> $GITHUB_OUTPUT
          echo -e "$FAILURE_REASONS" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

          # Log summary (quiet mode for success)
          if [ "$HAS_FAILURES" = "true" ]; then
            echo "::error::Agent execution had failures"
            echo ""
            cat /tmp/audit/report.md
          else
            echo "‚úÖ Agent execution completed successfully"
            echo "üìä View full audit report in workflow artifacts"
          fi
      - name: Checkout repository for diagnosis
        if: steps.audit-check.outputs.has-failures == 'true'
        uses: actions/checkout@v4
      - name: Generate GitHub token
        id: app-token
        env:
          GH_APP_ID: ${{ secrets.GH_APP_ID }}
          GH_APP_PRIVATE_KEY: ${{ secrets.GH_APP_PRIVATE_KEY }}
          FALLBACK_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |-
          # Check if GitHub App is configured
          if [ -z "$GH_APP_ID" ] || [ -z "$GH_APP_PRIVATE_KEY" ]; then
            echo "No GitHub App configured, using default GITHUB_TOKEN"
            echo "token=$FALLBACK_TOKEN" >> $GITHUB_OUTPUT
            echo "git-user=github-actions[bot]" >> $GITHUB_OUTPUT
            echo "git-email=github-actions[bot]@users.noreply.github.com" >> $GITHUB_OUTPUT
            exit 0
          fi

          echo "GitHub App configured, generating installation token..."

          # Base64 URL-safe encoding function
          base64url() {
            openssl base64 -A | tr '+/' '-_' | tr -d '='
          }

          # Generate JWT header
          HEADER=$(echo -n '{"alg":"RS256","typ":"JWT"}' | base64url)

          # Generate JWT payload (iat = now - 60s to account for clock drift, exp = now + 10 min)
          NOW=$(date +%s)
          IAT=$((NOW - 60))
          EXP=$((NOW + 600))
          PAYLOAD=$(echo -n "{\"iat\":$IAT,\"exp\":$EXP,\"iss\":\"$GH_APP_ID\"}" | base64url)

          # Sign the JWT with the private key
          UNSIGNED="$HEADER.$PAYLOAD"
          SIGNATURE=$(echo -n "$UNSIGNED" | openssl dgst -sha256 -sign <(echo "$GH_APP_PRIVATE_KEY") | base64url)
          JWT="$HEADER.$PAYLOAD.$SIGNATURE"

          # Get installation ID for this repository
          OWNER="${{ github.repository_owner }}"
          REPO_NAME="${{ github.event.repository.name }}"
          INSTALLATION_RESPONSE=$(curl -s -H "Authorization: Bearer $JWT" \
            -H "Accept: application/vnd.github+json" \
            -H "X-GitHub-Api-Version: 2022-11-28" \
            "https://api.github.com/repos/$OWNER/$REPO_NAME/installation")

          INSTALLATION_ID=$(echo "$INSTALLATION_RESPONSE" | jq -r '.id // empty')

          if [ -z "$INSTALLATION_ID" ]; then
            echo "::warning::Failed to get installation ID. Is the GitHub App installed on this repository?"
            echo "::warning::Response: $INSTALLATION_RESPONSE"
            echo "Falling back to GITHUB_TOKEN"
            echo "token=$FALLBACK_TOKEN" >> $GITHUB_OUTPUT
            echo "git-user=github-actions[bot]" >> $GITHUB_OUTPUT
            echo "git-email=github-actions[bot]@users.noreply.github.com" >> $GITHUB_OUTPUT
            exit 0
          fi

          # Generate installation access token
          TOKEN_RESPONSE=$(curl -s -X POST \
            -H "Authorization: Bearer $JWT" \
            -H "Accept: application/vnd.github+json" \
            -H "X-GitHub-Api-Version: 2022-11-28" \
            "https://api.github.com/app/installations/$INSTALLATION_ID/access_tokens")

          TOKEN=$(echo "$TOKEN_RESPONSE" | jq -r '.token // empty')

          if [ -z "$TOKEN" ]; then
            echo "::warning::Failed to generate installation token"
            echo "::warning::Response: $TOKEN_RESPONSE"
            echo "Falling back to GITHUB_TOKEN"
            echo "token=$FALLBACK_TOKEN" >> $GITHUB_OUTPUT
            echo "git-user=github-actions[bot]" >> $GITHUB_OUTPUT
            echo "git-email=github-actions[bot]@users.noreply.github.com" >> $GITHUB_OUTPUT
            exit 0
          fi

          # Mask the token in logs
          echo "::add-mask::$TOKEN"

          # Get app info for git identity
          APP_RESPONSE=$(curl -s -H "Authorization: Bearer $JWT" \
            -H "Accept: application/vnd.github+json" \
            -H "X-GitHub-Api-Version: 2022-11-28" \
            "https://api.github.com/app")

          APP_SLUG=$(echo "$APP_RESPONSE" | jq -r '.slug // "github-app"')
          APP_ID_NUM=$(echo "$APP_RESPONSE" | jq -r '.id // "0"')

          echo "‚úì Generated GitHub App token for $APP_SLUG"
          echo "token=$TOKEN" >> $GITHUB_OUTPUT
          echo "git-user=$APP_SLUG[bot]" >> $GITHUB_OUTPUT
          echo "git-email=$APP_ID_NUM+$APP_SLUG[bot]@users.noreply.github.com" >> $GITHUB_OUTPUT
        if: steps.audit-check.outputs.has-failures == 'true'
      - name: Setup Bun for diagnostic agent
        if: steps.audit-check.outputs.has-failures == 'true'
        uses: oven-sh/setup-bun@v2
        with:
          bun-version: latest
      - name: Run safe-mode diagnostic agent
        id: diagnostic
        if: steps.audit-check.outputs.has-failures == 'true'
        env:
          ANTHROPIC_API_KEY: ${{ secrets.ANTHROPIC_API_KEY }}
          CLAUDE_CODE_OAUTH_TOKEN: ${{ secrets.CLAUDE_CODE_OAUTH_TOKEN }}
        run: |

          # Prepare diagnostic context
          cat > /tmp/diagnostic-prompt.md << 'DIAG_EOF'
          You are a diagnostic agent analyzing a failed GitHub Actions workflow for the "Codebase Improver" agent.

          ## Your Task
          Analyze the failure data below and provide:
          1. A clear summary of what went wrong
          2. The root cause analysis
          3. Specific remediation steps the user can take to fix the issue

          ## Failure Information
          ${{ steps.audit-check.outputs.failure-reasons }}

          ## Audit Report
          $(cat /tmp/audit/report.md)

          ## Validation Status
          $(cat /tmp/audit-data/validation/validation-status.json 2>/dev/null || echo "Not available")

          ## Permission Issues
          $(cat /tmp/audit-data/validation/permission-issues.json 2>/dev/null || echo "[]")

          ## Agent Configuration
          - Agent name: Codebase Improver
          - Triggers: {"schedule":[{"cron":"0 6 * * 1"}],"workflow_dispatch":{"inputs":{"focus_area":{"description":"Focus area for improvements","required":false,"default":"all","type":"choice","options":["all","testing","code-quality","performance"]},"max_prs":{"description":"Maximum number of PRs to create","required":false,"default":"3","type":"string"}}}}
          - Permissions: {"contents":"write","issues":"read","pull_requests":"write"}
          - Outputs: ["create-pr","add-label"]

          ## Instructions
          Based on the above information:
          1. Write a concise but complete diagnosis
          2. Include specific file paths, configuration changes, or commands needed to fix the issue
          3. If it's a permissions issue, explain exactly what permission is missing and where to add it
          4. If it's a rate limit issue, explain when the user can retry
          5. Format your response in clean markdown suitable for a GitHub issue

          Do NOT use any tools that modify files. You are in read-only diagnostic mode.
          DIAG_EOF

          # Run diagnostic agent in safe mode (read-only tools)
          bunx --bun @anthropic-ai/claude-code \
            -p "$(cat /tmp/diagnostic-prompt.md)" \
            --allowedTools "Read,Glob,Grep" \
            --output-format json > /tmp/diagnostic-output.json 2>&1 || true

          # Extract the diagnosis
          if [ -f /tmp/diagnostic-output.json ]; then
            jq -r '.result // "Unable to generate diagnosis"' /tmp/diagnostic-output.json > /tmp/diagnosis.md
          else
            echo "Diagnostic agent did not produce output. Manual investigation required." > /tmp/diagnosis.md
          fi
      - name: Create failure issue
        if: steps.audit-check.outputs.has-failures == 'true'
        env:
          GITHUB_TOKEN: ${{ steps.app-token.outputs.token }}
        run: |

          # Build issue body
          cat > /tmp/issue-body.md << 'ISSUE_EOF'
          ## üö® Agent Failure Report

          The **Codebase Improver** agent encountered failures during execution.

          ### Workflow Details
          - **Run ID:** [${{ github.run_id }}](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})
          - **Triggered by:** @${{ github.actor }}
          - **Event:** ${{ github.event_name }}
          - **Time:** $(date -u +%Y-%m-%dT%H:%M:%SZ)

          ### Failure Summary
          ${{ steps.audit-check.outputs.failure-reasons }}

          ---

          ## üîç Diagnostic Analysis

          $(cat /tmp/diagnosis.md)

          ---

          ## üìä Full Audit Report

          <details>
          <summary>Click to expand audit report</summary>

          $(cat /tmp/audit/report.md)

          </details>

          ---

          *This issue was automatically created by the Repo Agents audit system.*
          ISSUE_EOF

          # Check if a similar issue already exists (avoid duplicates)
          EXISTING_ISSUE=$(gh issue list --state open --label "agent-audit" --search "Codebase Improver failure" --json number --jq '.[0].number' 2>/dev/null || echo "")

          if [ -n "$EXISTING_ISSUE" ]; then
            echo "Adding comment to existing issue #$EXISTING_ISSUE"
            gh issue comment "$EXISTING_ISSUE" --body "$(cat /tmp/issue-body.md)"
          else
            echo "Creating new failure issue"
            gh issue create \
              --title "üö® Codebase Improver: Agent Execution Failed" \
              --body "$(cat /tmp/issue-body.md)" \
              --label "agent-audit,codebase-improver" 
          fi
      - name: Upload audit report
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: audit-report
          path: /tmp/audit/
          if-no-files-found: ignore
permissions:
  contents: write
  issues: read
  pull-requests: write
