---
title: Repo Agents
description: CLI tool for creating AI-powered GitHub Actions workflows from markdown agent definitions
template: splash
hero:
  tagline: Transform natural language markdown files into GitHub Actions workflows powered by AI
  actions:
    - text: Quick Start
      link: /repo-agents/start
      icon: rocket
      variant: primary
---

import { Card, CardGrid, Steps } from '@astrojs/starlight/components';

## Overview

**Repo Agents** enables developers to create intelligent repository automation by writing simple markdown instructions instead of complex YAML configurations. Define AI-powered agents that can automatically triage issues, review pull requests, manage discussions, and more.

## Key Features

<CardGrid stagger>
  <Card title="Markdown to Workflow" icon="pencil">
    Write agent instructions in plain markdown—no YAML workflows to maintain
  </Card>
  <Card title="Repository-Wide Context" icon="document">
    Agents can collect issues, PRs, commits, and discussions to analyze trends
  </Card>
  <Card title="Guardrails by Design" icon="approve-check-circle">
    Agents can't freely modify your repo—all changes go through validated output handlers
  </Card>
  <Card title="Swappable Agent Core" icon="setting">
    Choose your AI provider—Claude Code, OpenCode, or add your own
  </Card>
  <Card title="Built-in Audit & Recovery" icon="warning">
    Automatic failure diagnosis and issue creation when things go wrong
  </Card>
</CardGrid>

## Quick Example

Create an issue triage agent in simple markdown:

```markdown
---
name: Issue Triage
on:
  issues:
    types: [opened]
permissions:
  issues: write
outputs:
  add-comment: { max: 1 }
  add-label: true
---

# Issue Triage Agent

Analyze new issues and:

1. Categorize with appropriate labels (bug, feature, documentation, question)
2. Assess priority (high, medium, low)
3. Welcome the contributor with a friendly comment

Be helpful and welcoming!
```

Then compile it to a GitHub Actions workflow:

```bash
repo-agents compile
```

## How it works

<Steps>

1. **Write agent definitions** in `.github/agents/*.md` using natural language instructions

2. **Compile to workflows** with `repo-agents compile`—this generates standard GitHub Actions YAML

3. **Triggers fire** when issues open, PRs are created, on a schedule, or other GitHub events

4. **Claude executes** your instructions with only the permissions and outputs you've allowed

</Steps>

## Why not just write GitHub Actions?

Traditional GitHub Actions require you to anticipate every scenario and write explicit conditional logic. Repo Agents is different:

| Traditional GitHub Actions | Repo Agents |
|---------------------------|-----------|
| Rigid if/else logic | AI interprets context and makes judgment calls |
| Regex-based text matching | Natural language understanding |
| Separate scripts for each case | Single set of instructions handles variations |
| Breaks when edge cases appear | Adapts to unexpected situations |

For example, labeling issues traditionally requires regex patterns for each label. With Repo Agents, you write "label bugs as `bug`, feature requests as `feature`" and the AI understands variations like "this doesn't work", "can you add support for X", or "I found an issue where...".

## Prerequisites

Before getting started, you'll need:

- **GitHub CLI** (`gh`) installed and authenticated
- **A GitHub repository** where you have write access
- **Claude API access**: either an API key or OAuth token (set up during installation)

## Safe and controlled

Repo Agents generates workflows with multiple safety layers:

- **Explicit permissions**: Agents only get the GitHub permissions you specify (`contents: read`, `issues: write`, etc.)
- **Constrained outputs**: Define exactly what actions agents can perform—can't create PRs unless you allow it
- **User authorization**: Control who can trigger agents (admins only, specific users, org members)
- **Path restrictions**: Limit file operations to specific directories with glob patterns
- **Rate limiting**: Built-in cooldowns prevent runaway execution

## Example use cases

- **Issue triage**: Label and categorize issues based on content, ask clarifying questions
- **PR review**: Analyze code changes, check for common issues, suggest improvements
- **Documentation sync**: Update docs when code changes, flag outdated sections
- **Release notes**: Generate changelogs from merged PRs with intelligent categorization
- **Dependency monitoring**: Check for updates on a schedule, create upgrade PRs
- **Community management**: Welcome new contributors, answer common questions
